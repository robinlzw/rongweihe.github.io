<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>在宇宙中心五道口上班，是怎样一种体验</title>
      <link href="/2020/05/02/zai-yu-zhou-zhong-xin-wu-dao-kou-shang-ban-shi-zen-yang-yi-chong-ti-yan/"/>
      <url>/2020/05/02/zai-yu-zhou-zhong-xin-wu-dao-kou-shang-ban-shi-zen-yang-yi-chong-ti-yan/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>今天要不是 CSDN 的小编姐姐催我，我都没发现自己一个月没更新文章了，抽自己一巴掌先，主要这段时间有点忙，呵呵，又给自己找借口了是吧。玩笑归玩笑，反正是自己失职了，希望各位读者大大也能时刻监督我这个懒人公众号作者。。。这样我就有力量更新文章了，嘿嘿。</p><p>今天趁着五一的假期，给大家分享下我最近工作的一些日常吧（实在没啥好写的，写技术文没多少人看，呜呜。好难呀）</p><h3 id="1、为什么叫宇宙中心？"><a href="#1、为什么叫宇宙中心？" class="headerlink" title="1、为什么叫宇宙中心？"></a>1、为什么叫宇宙中心？</h3><div align="center"> <img src="https://i.loli.net/2020/05/02/scPA14TrtFkJNni.jpg"width="300"/> </div><br><p>（五道口地铁站）</p><p>看一下上面这张图，每天上下班都要坐这个地铁站。</p><p>“火车向左走，城铁向右走，不动的便是五道口。”</p><p>看楼上的字，“U-CENTER 五道口”，</p><p> “U-CENTER 五道口” U=Universe，简称-宇宙中心。。。</p><p>如果上面的 U 让你想到 University 的话，那么恭喜你悟到了。在五道口这个地方，也汇集了许多宇宙一流和离宇宙一流很近的学府。比如，清华大学，还有中华高丽学院（不是后宫佳丽三千的那个佳丽）：</p><p>你可能会说了，”我又不在那里上学，这个中心与我何干”。</p><p>ok，那么请问你，有木有参加过高考、自考、研究生考试呢？</p><p>有没有参加过四级六级计算机等级考试呢？</p><p>有没有参加过托福雅思雅呢？</p><p>……</p><p>如果有，那么，敢说下面这个中心不是绝对的中心么？（突然感觉到一股严肃的气氛）</p><div align="center"> <img src="https://i.loli.net/2020/05/02/KzQma2Ac7ZwfCkp.jpg"width="300"/> </div><br><p>（教育部考试中心）</p><p>其实上面两个地方我也没去过，只是从别的地方找的图片，不过下面这个，每天上班都能看到了，因为这个就是公司园区了，清华科技园的斗牛，每天上班前看一看，一天的热情就仿佛被点燃了。</p><div align="center"> <img src="https://i.loli.net/2020/05/02/4FGrJ6ht5fuINHS.jpg"width="300"/> </div><br><p>（园区的斗牛像）</p><p>在五道口，除了宇宙一流的学校，还有宇宙一流的众公司们。</p><div align="center"> <img src="https://i.loli.net/2020/05/02/FD3kOUyXcwaeZp5.jpg"width="300"/> </div><br><p>（众公司的标志旗帜和国旗）</p><p>五道口金融学院，每天上下班，路过大门，不过，从来没进去过，在里面的那都是顶尖的金融专家了。</p><p>好了，前面铺垫了那么多，开始转入正题了。</p><h3 id="2、工作两个月了"><a href="#2、工作两个月了" class="headerlink" title="2、工作两个月了"></a>2、工作两个月了</h3><p>从今天算起，满打满算，工作已经两个月多了。</p><p>虽然时间不长，但对我来说，这段时间的经历和忙碌，对我却有着不一样的意义，趁着五一假期，看看过去的自己，总结和反思，好的习惯要继续保持，不好的习惯要及时改正过来，看清现实，调整方向，才能从新出发。</p><p>这两个月，是我从学生阶段进入到职场阶段的关键时期，也是我人生的第一份正式工作，所以我倍加注重。</p><p><strong>人生就像一段长跑，刚进入社会后，有点像从一个明亮光明的地方（从小到大，我们的目标一直都非常明确，要读最好的初中，要读最好的高中，要考最好的大学），突然之间，毕业了，来到一个没有赛道没有灯的地方。想要成为什么样的人得自己把握，怎么成为想要自己成为的人需要自己寻找方法。</strong></p><p>所以有一段迷茫期都是正常的。</p><p>从一开始的不知所措，到后面慢慢步入正轨，这段时间，离不开这些人的帮助：</p><p>1、感谢同事锐哥，刚进入部门的时候，在对部门的开发环境和项目各方面，并不是很熟悉的情况下，耐心的回答我提出的一些小白的问题，给我一些建议：如何高效的阅读项目源码；在做一个需求之前应该学会提前和客户端对接好接口文档，然后才开始开发。</p><p>2、感谢大白师兄，感谢在我入职的时候，在一个职场萌新心理上的过渡期间，无私的给予我工作上的建议和鼓励，虽然师兄觉得我有点客气了，但我觉得感谢是应该的，别人无私的给你建议，帮你解答你的疑问，有的时候感觉真的很暖，毕竟别人帮你是情分，不帮你是本分，刚入职那会，师兄正好跳槽去了字节跳动，所以没有来得及请师兄吃顿饭，不过反正以后都有时间，等这段时间过去了，再去找师兄好好聊聊。</p><p>两个月的时间，从一个什么都不懂的完全小白，各方面都战战兢兢的，害怕搞砸的小白，到现在自己能独立负责一个需求，独立开发，和部门其它同事一起联调一个项目，最后上线。</p><p>期间，自己学习了很多，相信，更多的挑战还在前方，未来还要继续加油。</p><h3 id="3、生活的日常"><a href="#3、生活的日常" class="headerlink" title="3、生活的日常"></a>3、生活的日常</h3><p>生活，除了每天的工作，吃饭，睡觉，对我来说，有一件反复坚持又放弃，坚持又放弃的事情，那就是早起了，之前在学校的时候也坚持过，要早起，可是后来实在坚持不下来，就弃疗了。。。</p><p>每天定好几个闹钟：7 点的，8 点的，9 点的，但无一例外，几乎都要磨磨蹭蹭到 8：30 左右起床，起床了，在床上发一会呆，看看窗外，听听外面的车水马龙的声音，小区的人们也开始活动起来了。</p><p>最近发现的事，每天早上，小区楼下，都能听到打鞭的声音，好像有个大爷在那活动，我还在睡梦中，就被这种声音给吵醒了，这下好了，我晚上睡觉一般不关窗，早上被自然吵醒了，也不知道早上几点就开始活动了，反正每次被叫醒都已经 8 点多了，正好，这样也没有定闹钟的必要了。。。</p><p>起床之后，洗脸刷牙，喝一碗昨晚提前煮好的粥，加一片面包，再来一杯核桃早餐牛奶，嘿嘿，早餐要吃好，要保证一定量的蛋白质，不然中午容易饿。</p><p>收拾书包，笔记本，大概 9 点左右就能出门，说实话，每次出门前都要进行一番心理斗争，因为接下来就是一天最恐怖的时候，开始挤地铁-西二旗地铁站。</p><p>每天上班都要在西二旗站换乘，北京早高峰的地铁实在是太挤了，西二旗站连接着 13 号线和昌平线，每到一趟昌平线列车，都是一场赛跑，车门就像是起跑线，大家都怕比人慢一步，两大拥挤的地铁线交接处，你说有多恐怖呢？有多挤？我看到一次，别人的假发都挤掉了！而且，现在天气也变热了，地铁上人一多，气味就更大了。</p><div align="center"> <img src="https://i.loli.net/2020/05/02/mIh6cQ81efLEvXx.jpg"width="500"/> </div><br><p>（西二旗早高峰实拍）</p><p>但是没办法，毕竟帝都，毕竟北京，都是这样，生活就是这么不容易啊（什么时候上班可以不用挤地铁那就好了）。</p><p>还好自己住的地方离公司比较近，不然，通勤路上实在折磨的很。大概 30-40 分钟，10 点前就能到公司了，这个点，又巧了，大家正好都来了，做电梯，又是一个需要看眼疾手快的活了。</p><p>北京这边防护管的很严，每次出小区都要查体温和检查出入证，进公司小区也要量体温、检查健康证。我所在的部门在 8 楼，坐电梯到 8 楼前台，扫码可以免费领取口罩，每天一个，然后到工位，打开笔记本，接杯水，上一趟厕所，回来开始上午的工作。</p><h3 id="4、一天的工作安排"><a href="#4、一天的工作安排" class="headerlink" title="4、一天的工作安排"></a>4、一天的工作安排</h3><p>最开始的时候，因为我不太清楚部门的项目业务逻辑，我就给自己发明一种学习的方法，叫面向邮件学习业务。</p><p>什么意思呢？因为组里的同事都在一个邮箱组的，这样大家有最新的开发任务和代码版本，发邮件的时候，都会抄送到组里，这样一来，你能实时关注到其它同事的最近在忙什么。</p><p>而且有时候提测的时候会发代码的 diff，你在OA 系统里申请下权限，就可以看到别人最近的写的代码，这样，虽然每个人负责的具体需求不一样，但都是组里的项目，你会看到别人在负责哪些模块，以及他写的的代码的逻辑和规范，这些都是刚开始可以学习参考的入口啊，不过，上面我这个方法适合于最开始的阶段，等你摸清了需求这一整套下来，你自己也就能慢慢上手了。</p><p>在正式一天的工作之前，我都会利用笔记，列举今天要做的事情，我常用的是有道云笔记。其实每一天工作的前一天晚上，我都会在笔记本上记录第二天要干啥，所谓，好记性不如烂笔头，这样有记录有计划，第二天工作就能分清楚主次了，也能防止自己忘记一些东西。我觉得这种习惯对我很有帮助。</p><p>一般上午的话，主要是打开邮箱，查收一下有没有新的邮件，每一天公司的邮箱会收到好的邮件，然后处理下邮件；在终端里远程连一下服务器，看下之前的程序有没有问题，查看日志，然后继续写代码，跑程序。</p><p>然后差不多到 12 点多，就到了午饭时间了，一般是自己提前一天晚上做好饭，然后带到公司茶水间，用微波炉热一下，有的时候改善下伙食，去楼下超市买一份自助餐，或者和同事点份外卖。</p><div align="center"> <img src="https://i.loli.net/2020/05/02/FX6SQDmutNvWoGb.jpg"width="300"/> </div><br><p>（20 一份的孜然鸡肉土豆片）</p><p>价格的话，平均一份自助餐，20-30 块左右，外卖要稍贵些，但是，这还不是最贵的，五道口的雪糕感觉是最贵的，一根 10 块起步。。。突然很怀念小时候，五毛钱一根的冰棒。。。</p><p>雪糕。。</p><p>下面这张图，是有一次部门总监请大家吃雪糕，我自己拿了一根，咬了一口，然后拍了一张，你没看错，就这样的，据说还不止十块钱呢。</p><p>因为大家的工位都挨着，而且因为现在公司空调还没开放，我觉得把饭菜端进来吃，味道会影响到别人，所以一般没有在工位上吃饭的习惯，都是买好饭，去公司的茶水间吃。茶水间有微波炉，如果买的菜不够热，可以热一下在拿出来吃。</p><p>吃完饭，中午回来工位，开始午休一会，大概眯眼休息会 30 分钟左右，开始下午的工作，其实一天的工作量，主要在体现在下午了。</p><p>1、如果来了新需求，老大会安排参加需求评审会；然后会后有一个需求文档，你自己问清楚自己要负责的哪个模块；因为自己是后端开发，所以你还要和客户端，前端讨论具体需求，每个细节都要过一遍，确保双方都没有问题，然后自己确定技术方案，具体开发任务之前一般是要写好接口文档，写好之后也要给用接口的同事看一下，看看有没有问题，没有问题的话，就可以进入下一个步骤了。</p><p>2、下一个步骤就是开发任务了，在具体开发之前，需要自己看一下排期，准备多久开发完，开发完多久可以提测，这样要和测试那边的同事沟通，代码开发完了，需要自己测试，然后需要同事 codereview 一下。</p><p>3、如果都没问题了，接下来，你要和用到接口的同事在沟通时间，整体联调一下，主要是看看上线之前能不能跑通，如果没问题，接下来就可以提测了，提测之后要跟测，跟测中肯定会出现一些你意想不到的各种问题，第一次做一个需求之前。由于自己没有经验，第一次提测报了好几个 bug，虽然这很正常，但是很想把它做好，毕竟，想给其它人留下一个好印象。</p><p>4、因为测试的同事毕竟是专业的，我狗的测试同学，论工作态度和认真程度我是服气的。各种异常情况都能给你考虑到，而且呢，我们组主要负责搜索 APP 的后端，APP 发版上线之后，用户的点击行为是不确定的，所以这也就意味着，在代码正式上线之前，需要各种情况都考虑到，严格按照流程来走一遍。最后测试如果没问题，会发一封测试通过，可以上线的邮件，然后你就可以合并你的代码到主分支了，部署代码到线上服务器了。</p><p>5、最后上线完了，还没结束，你还需要和测试的线上盯一盯，看看有没有其它异常，如果没有异常，OK，这个需求就可以算正式完成了，可以稍微歇一下了。</p><p>6、这两个月，我基本上都坚持早上第一个到公司，晚上最后一个离开，平均差不多 10 点左右下班的样子，刚工作，自己各方面不是很熟悉，而是我是正式员工身份，需求驱动开发，必须要快速上手业务，要学的东西很多，慢慢来，注意劳逸结合，周末一般是周六，会抽出半个小时，去小区跑跑步，锻炼身体，然后白天学习一天，看看书，听听歌，周末的话，就休息了，好好调整调整。</p><div align="center"> <img src="https://i.loli.net/2020/05/02/OoMh7XwZGPUxkmN.jpg"width="300"/> </div><br><p>（夜晚的园区）</p><h3 id="5、几点感悟"><a href="#5、几点感悟" class="headerlink" title="5、几点感悟"></a>5、几点感悟</h3><p>老大给你安排的活，有的时候分配下来，你有很多地方不清楚，这太正常不过了，有的时候老大也很忙，不好意思打扰或者问了没有回答，这个时候，我们要学会自我驱动，在开发一个任务之前，一定要搞清楚需求，问明白，自己知道怎么做了的时候，这个时候才进入开发状态。</p><p>作为一名初级开发者，在给出指导和具体的实施细节之后，需要能独立，按时按量（数量和质量）完成工作。上班的时候，就好好上班，尽力把自己负责的部分做的最好，这样对其它同事的工作也有帮助。</p><p>在朋友圈看到有人分享雷布斯说过的一句话：</p><p><strong>时间是自己的，你到一个公司打工的时候，偷懒，老板没有看见，就觉得自己又蒙了一下，玩猫和老鼠的游戏，真是没有必要。公司所付的工资， 就买下了你几个月的青春？学会的东西首先是自己的，其次才是公司的。没有多少人真正计算过自己一个小时值多少钱。</strong></p><p>我觉得这段话，对我很有启发，也许这就是人和人的差距吧，虽然我们做不到雷布斯那样的严格要求自己，但我们每个人，打工的同时，都要明白学会的东西首先是自己的，自己负责的东西尽力做好最好。</p><p>平时的工作，碰到不明白的问题，我一般直接在 Google 用关键词搜索，面向 stack overflow 编程。</p><p>提问之前，我一般是先自己搜索解决，实在解决不了，把问题的描述清楚，你认为是怎么做的，你自己打算怎么解决，然后最好一次性是把问题问好，大家都很忙，你提问别人同时也是占用别人的时间，要谦虚请教。</p><h3 id="6、时刻保持学习心态"><a href="#6、时刻保持学习心态" class="headerlink" title="6、时刻保持学习心态"></a>6、时刻保持学习心态</h3><p>IT 行业一直是一个快速迭代更新的行业，这个行业变化太快，以至于稍微跟不上，可能就会面临淘汰。</p><p>我是一个很有危机感的人，步入工作的第一天起，我就在想，如果有一天我丢掉了这份工作，还有没有公司愿意给我机会，因此，我时刻要求自己，对新技术保持持续的热情和兴趣，生怕在这个时代技术落伍。</p><p>所以，我白天除了做好自己的工作之外，忙里偷闲的，也会带薪学习，晚上，下班回到家，也会学点跟自己工作相关的知识，平时用到的技术栈等等，比如我项目中用到了 Go，我就学习 Go；项目中用到了数据库和第三方中间件，我就学 MySQL，Redis 等等这些。一般呢，我会去官网上看官方的 tutorial ，配合一些代码实践；另外就是我在极客时间上买了一些专栏，也会看着学习，记录笔记。</p><p>这里有个问题就来了，人，都会懒惰的，学习是反人性的，往往会陷入到一种情况，就是刚开始学习一段时间，你会觉得充满新鲜感，有激情，记笔记，做实践，好像陷入一种持续亢奋的学习状态中，甚至有的人，比如我就是，恨不得立马一周时间就学完和搞定眼前这门课程。</p><p>可是，随着时间的推移，加上平时工作的忙碌，你发现你根本想多了，你发现你学习的动力慢慢降低了，以至于你有时候下班回家，打开极客时间或者其他学习网站，内心有一种抵触的感觉，就是不想看，就是想葛优躺，玩手机，这种情况怎么办呢。</p><p>最近我看到别人的一个说法，反馈激励法，也就是说，比如你今天学习了一节 MySQL 课程，就给自己奖励去超市购物或者去看一部电影，有的人可能说了，这个激励有 bug 啊，激励的对象虽然是你自己，但是付钱的也是你自己啊😭（不像小时候，你在课堂上，积极回答一个问题，老师奖励你一朵小红花或者一颗糖）。</p><p>哈哈，上面这样想也没错，换个思维，现在大家都是成年人了，虽然去超市购物、去看电影，花的是自己的钱，但享受的也是自己，给自己花钱，难道还不开心么？要想的开一些。哈哈。</p><p>学习就是这样，一开始激情满满，然后满满激情褪去，所以大部分人才坚持不下去，所以呢，我一直觉得，能学下去的人，都是逼迫自己的、有很强的毅力的人，而这部分人也是少数。</p><p>自律不太行，那就去寻找一些他律，没事去看看招聘网站上薪资最高的那种职位，然后给自己定一个小目标，这样一提到赚钱，自己就更有动力了，哈哈。</p><h3 id="7、总结"><a href="#7、总结" class="headerlink" title="7、总结"></a>7、总结</h3><p>好了，啰里啰嗦，又写了这么多了，这篇文章，就是描述下自己平白朴实的生活日常。如果觉得有共鸣，欢迎一起交流留言，欢迎多多指教！</p><p>最后祝大家五一假期愉快哦。</p><br/><blockquote><ul><li>本文已收录至我的 GitHub 程序员成长系列【MoreThanCode】 ，欢迎 star：<a href="https://github.com/rongweihe/MoreThanCode" target="_blank" rel="noopener">https://github.com/rongweihe/MoreThanCode</a></li><li><strong>个人公众号</strong> ：herongwei，<strong>个人独立域名博客</strong>：herongwei.com，坚持原创输出，下方扫码关注，2020，与您共同成长！</li></ul></blockquote><div align="center"> <img src="https://i.loli.net/2020/04/18/m19Xng7Zo6PcfIY.jpg"width="500"/> </div><br><p>非常感谢各位老铁能 <strong>看到这里</strong>，如果觉得本篇文章写得不错，觉得 <strong>「herongwei」是一个认真的仔</strong> 的话，<strong>求点赞，求关注，求分享，求留言哦！</strong></p><p>创作不易，各位老铁的支持和认可，就是我创作的最大动力，我们下篇文章在见！</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> 职场 </tag>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对你的知识做最好的投资</title>
      <link href="/2020/04/19/dui-ni-de-zhi-shi-zuo-zui-hao-de-tou-zi/"/>
      <url>/2020/04/19/dui-ni-de-zhi-shi-zuo-zui-hao-de-tou-zi/</url>
      
        <content type="html"><![CDATA[<blockquote><p>周末阅读了 Andrew Hunt 和 David Thomas 所著的经典——《程序员的修炼之道（第二版）》，发现这本书最早虽然是 1999 年写的，距今已有将近 20 年，但书中的内容，依然经典实用。尤其是读到“知识组合”一文，感慨良多，将全文摘录，分享给大家。</p></blockquote><blockquote><p>《程序员的修炼之道》这本书值得每一位程序员认真阅读，反复阅读。</p></blockquote><p><strong>知识上的投资总能得到最好的回报。——本杰明·富兰克林</strong></p><p>对于我们每个人来说，知识和经验是我们最重要的专业资产。从小到大，我们上学，考试，学习，这些都是在增加我们的知识和经验。</p><p>但是我们也需要注意的是，知识和经验最大的特定在于它的时效性，也就是说，它们是一种时效资产。随着新技术的出现，以及语言和环境的发展，旧有的知识会很快变得过时，尤其是在互联网行业。变化太快，也许你现在的所学的技能在未来几年可能就会被淘汰。同时，不断变化的市场力量，包括市场需求可能会使经验变得陈旧而无关紧要。</p><p>因此，有人提倡“终身学习”的理念，不可否认，学习新事物的能力是我们每一个人最重要的战略资产。</p><p>我们该如何学习“学习”本身呢？如何知道该学什么呢？</p><h3 id="1、知识组合"><a href="#1、知识组合" class="headerlink" title="1、知识组合"></a>1、知识组合</h3><p>所谓知识组合，指的就是将程序员所了解的一切有关计算过程的事实、工作的应用领域，以及所有经验，视为拥有的<strong>知识组合</strong>，管理知识组合和管理金融投资组合其实非常的类似：</p><blockquote><p>1、正规投资者有定期投资的习惯。</p><p>2、多样化是长线成功的关键。</p><p>3、聪明的投资者会平衡保守型和高风险高回报型投资的组合。</p><p>4、投资者用低买高卖来获得最大的回报。</p><p>5、定期审查和重新平衡投资组合。</p></blockquote><p>要想事业成功，你必须用同样的指导方针管理你的知识组合。</p><p>管理这类投资是一项技能，就像其它技能一样–可以学会。这里的诀窍在于是让自己一开始就这样做，并养成习惯。制定一个你能遵循的例行流程，并且坚持的照此去做，直到你的大脑将其内化自己的知识。做到这个程度之后，你会发现自己会自动吸收新知识。</p><h3 id="2、构建知识组合"><a href="#2、构建知识组合" class="headerlink" title="2、构建知识组合"></a>2、构建知识组合</h3><ul><li><strong>定期投资</strong>：就像金融投资一样，你必须定期为你的知识组合投资，即使数量有限。习惯本身就和总数量一样重要，所以要安排一个固定的时间和地点，这样有助于排除常见干扰。</li><li><strong>多样化：</strong>你知道的东西越多，你的价值就越大。起码要知道目前工作中特定技术的来龙去脉，但不要就此打住。计算机技术变化迅猛–今天的技术热点可能到了明天就被淘汰。熟悉的技能越多，越能适应变化。</li><li><strong>风险管理：</strong>不同技术在从高风险回报到低风险回报的区间均匀分布。把所有的钱都投在高风险股票中非常不明智，因为有可能突然崩盘，同样你也不应该把所有的钱都投在在保守的领域，那样可能会错失良机。不要把所有的技术鸡蛋放在用一个篮子里。</li><li><strong>低买高卖：</strong>在一项新技术变得流行之前就开始投入时间学习，可能和发现一只被低估的股票一样困难，但是所得到的收获会和此类股票的收益一样好。</li><li><strong>重新评估和平衡：</strong>这是一个充满活力的行业。你上个月开始研究的热门技术现在也许已像石头一样冰冷。也许你需要刷新一下有段时间没有使用的数据库技术。或者，不妨去尝试另一种语言，它可能会让你在新的工作中处于更有利的地位。</li></ul><h3 id="3、对知识组合定期投资"><a href="#3、对知识组合定期投资" class="headerlink" title="3、对知识组合定期投资"></a>3、对知识组合定期投资</h3><p>在所有的这些指导方针中，最重要的下面这条做起来反而最简单。</p><ul><li><strong>每年至少学习一种新语言：</strong>不同语言以不同方式解决相同的问题。通过学习若干不同的方法，可以帮助你拓宽你的思维，避免墨守成规。此外，现在学习许多语言已容易了许多，网上可以免费获取丰富的教程和资源。</li><li><strong>每月阅读一本技术书籍：</strong>虽然网络上有大量的文章和偶尔靠谱的答案，但深入理解还需要去阅读长篇的书籍。可以在网上书店挑选和你当前项目主题相关的技术图书。一旦你养成习惯，就一个月读一本书。在你掌握了你正在使用的技术之后，扩展你的领域，阅读一些与你的项目无关的书籍。</li><li><strong>也要阅读非技术书籍：</strong>记住计算机是由人来使用的，你做的事情是为了满足人的需要，这非常重要。和你在一起工作的是人，雇佣你的也是人，黑你的还是人。我们需要学习不同的技能，可以称之为软技能，这虽然听起来很容易，但实际上它们很硬核，难以掌握。</li><li><strong>上课（在线学习）：</strong>在本地的学院或大学、或是将要来临的下一次商业会展或者技术会议上寻找有趣的课程。</li><li><strong>参加本地用户组织：</strong>不要只是去听讲，而要主动参与。独来独往对你的职业生涯来说可能是致命的；打听一下你们公司以外的人都在做什么。</li><li><strong>试验不同的环境：</strong>如果你只在 Windows 上工作，那么可以花点时间玩一玩 Linux。如果你只用过 makefile 和编辑器，就试一试 IDE，反之亦然。</li><li><strong>与时俱进：</strong>关心一下和你当前项目不同的技术，阅读相关的新闻和技术贴。这也是一种很好的方式，可以了解用到那些不同技术的人的经验以及他们所用的特殊术语。上网，查找论文、商业站点，以及其他任何你可以找到的信息来源。等等。</li></ul><br/><blockquote><ul><li>本文已收录至我的 GitHub 程序员成长系列【MoreThanCode】 ，欢迎 star：<a href="https://github.com/rongweihe/MoreThanCode" target="_blank" rel="noopener">https://github.com/rongweihe/MoreThanCode</a></li><li><strong>个人公众号</strong> ：herongwei，<strong>个人独立域名博客</strong>：herongwei.com，坚持原创输出，下方扫码关注，2020，与您共同成长！</li></ul></blockquote><div align="center"> <img src="https://i.loli.net/2020/04/18/m19Xng7Zo6PcfIY.jpg"width="500"/> </div><br><p>非常感谢各位老铁能 <strong>看到这里</strong>，如果觉得本篇文章写得不错，觉得 <strong>「herongwei」是一个认真的仔</strong> 的话，<strong>求点赞，求关注，求分享，求留言哦！</strong></p><p>创作不易，各位老铁的支持和认可，就是我创作的最大动力，我们下篇文章在见！</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> 投资 </tag>
            
            <tag> 程序员修炼之道 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>何谓玄学</title>
      <link href="/2020/04/18/he-wei-xuan-xue/"/>
      <url>/2020/04/18/he-wei-xuan-xue/</url>
      
        <content type="html"><![CDATA[<h1 id="何谓玄学？"><a href="#何谓玄学？" class="headerlink" title="何谓玄学？"></a>何谓玄学？</h1><p>所谓玄，最早出现在经典古籍《老子》的“玄之又玄，众秒之门”。这里的“玄”与道同义，指的是天地之间总的规律。最著名的玄学家之一王弼在《老子指略》中将玄解释为深远。所谓玄学，就是深远、深邃的学问。</p><blockquote><p>注：此玄学非彼玄学，指的是一种学问。</p></blockquote><p>这样说还是太深奥了，用现代化语言总结来说，所谓玄学，不是一个像现代儒教一样体系化的东西，而是故意将原来的体系否定掉。玄学其实是一种质疑精神，一种方法论，对五花八门的现象提出质疑、辩论，恢复人的思考能力，这种态度就是玄学。它其实更多的是教会人如何思辨地看待世界、理解世界。</p><blockquote><p>注：把玄学看做是一种质疑精神，这种想法还是挺新奇的。</p></blockquote><p>当你看到有的人品格很高，但才能很低，有的人满肚子坏水却又很有能力，突然想到，这和圣人教导的“人的天赋与道德是统一的”不是自相矛盾了么？于是你经过思考，提出了人的“才干”和“品德”是分离的，这个理论虽然小，但你思考的过程其实就是玄学。</p><blockquote><p>注：从小到大，我们都被教导要做一个德智体美全面发展的人，慢慢的，我们发现，这样的人很少，十全十美的人并不存在，伟人也有缺陷和犯糊涂的时候，“才干”和“品德”是可以分开的。</p></blockquote><p>当你思考万物的背后有什么，是不是有老天爷，最后得出结论，不是老天爷，而是“无”或者“空”，有点儿类似于大爆炸理论的奇点，这样的思考也属于玄学。</p><p>当你读到孔子不喜欢郑国和卫国的音乐，说它们是“淫声”，你提出质疑：声音还有什么好坏！然后去论证这个质疑，最后得出结论：声音没有悲哀和欢乐。这个论证过程就是玄学。</p><p>当你思考“语言到底能不能把客观世界全都表达出来”，并想出了一个巧妙的论证，这就是玄学。</p><blockquote><p>注：思考一个不寻常的问题，并且想出了一个论证，这就是玄学？总感觉有怪怪的，好像是又不是，不是又是。</p></blockquote><p>玄学包含的内容五花八门，看上去各不相干，但它们有一个共同的特点，就是用思辨的逻辑去分析问题，不要人云亦云。这个特点让玄学成了打破旧有观念的最好武器。</p><p>玄学为了发展思辨性，也有着一定的理论储备作为弹药库。 </p><p>这个弹药库包括三本书：《周易》《老子》《庄子》。这三本书 称为“三玄”。其中《周易》是儒家经典，《老子》《庄子》是道家经典。玄学更偏向于道，之所以对《周易》重视，在于这本书与其他的儒教经典有所不同。</p><blockquote><p>注：《周易》《老子》《庄子》。“三玄”真是博大精深。</p></blockquote><p>其他的儒教经典强调的是一个“礼”字，周代是一个最尊重礼的朝代。但在“礼”之外，周代也从夏商两代继承了另一个特征：占卜文化。《周易》就是一本关于占卜的书，与其他书强调“礼”不同，《周易》强调的是“变”，与其说是周代文化，不如 说是更早文化的残留。</p><p>秦始皇焚书坑儒时期，将其他的儒家经典都烧了，却保留了《周易》，因为他根本不觉得这本书是儒家的，只认为它就是一 本占卜书。</p><p>《周易》的变还不是特殊的变，而是千变万化。由于占卜是 一种高度不确定的行为，对《周易》的解读也是五花八门，莫衷 一是。这种自由度让《周易》成了历代术士的宝库，可以对它进 行随心所欲的解读，即便现在，算命先生们也总宣称是利用《周易》来算卦的。</p><p>道家、玄学、阴阳学都看上了《周易》的千变万化，当需要找古书来证实自己的理论时，总是将这本最含糊的书揪出来。 虽然三本经典有了，玄学的出现，还是一个漫长的过程。</p><blockquote><p>注：《周易》是本含糊的书（虽然我才看过几页。。）有句话这样说来着：世界上唯一不变的就是变，或许这也是《周易》一直得到人们的关注的最大原因吧，书名带个“易”字，让人就觉得此书不简单，带着一种高度的不确定性和神秘感。</p></blockquote><p>原文摘抄自：《中央帝国的哲学密码》（郭建龙-著）。</p><p>豆瓣读书：<a href="https://book.douban.com/subject/30276702/" target="_blank" rel="noopener">https://book.douban.com/subject/30276702/</a></p><br/><blockquote><ul><li>本文已收录至我的 GitHub 程序员成长系列【MoreThanCode】 ，欢迎 star：<a href="https://github.com/rongweihe/MoreThanCode" target="_blank" rel="noopener">https://github.com/rongweihe/MoreThanCode</a></li><li><strong>个人公众号</strong> ：herongwei，<strong>个人独立域名博客</strong>：herongwei.com，坚持原创输出，下方扫码关注，2020，与您共同成长！</li></ul></blockquote><div align="center"> <img src="https://i.loli.net/2020/04/18/m19Xng7Zo6PcfIY.jpg"width="500"/> </div><br><p>非常感谢各位老铁能 <strong>看到这里</strong>，如果觉得本篇文章写得不错，觉得 <strong>「herongwei」是一个认真的仔</strong> 的话，<strong>求点赞，求关注，求分享，求留言哦！</strong></p><p>创作不易，各位老铁的支持和认可，就是我创作的最大动力，我们下篇文章在见！</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> 哲学 </tag>
            
            <tag> 玄学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一文搞定 UDP 和 TCP 高频面试题</title>
      <link href="/2020/04/11/yi-wen-gao-ding-udp-he-tcp-gao-pin-mian-shi-ti/"/>
      <url>/2020/04/11/yi-wen-gao-ding-udp-he-tcp-gao-pin-mian-shi-ti/</url>
      
        <content type="html"><![CDATA[<p><strong>前言：</strong></p><blockquote><p>原文首发于知乎：<a href="https://zhuanlan.zhihu.com/p/10882285" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/10882285</a></p><p>目前已收获 800+ 个赞。</p></blockquote><blockquote><p>找工作面试，不管是春招还是秋招，面试官会经常问到 UDP 和 TCP，就拿自己参加的 2019 春招和秋招来说，加起来一共参加了 50 来场大大小小的面试，<strong>几乎每一轮面试，面试官都会问到计算机网络的知识，尤其是 UDP 和 TCP 的知识点。</strong></p><p>面试参加多了，会发现面试官几乎问来问去都是那几个问题，如果我们提前把这些问题搞得明白些，相信，下次参加面试你心里也有一定的自信了，也就能给面试官留下不错的印象，那么今天就来看看，给大家总结其中的核心高频面试题都有哪些，再有面试官问你相关的知识点，看这篇就差不多。</p><p>PS：文章有点长，请耐心阅读。</p></blockquote><p>目录：</p><p><strong>1、UDP 和 TCP 的特点与区别</strong></p><p><strong>2、UDP 、TCP 首部格式</strong></p><p><strong>3、TCP 的三次握手和四次挥手</strong></p><p><strong>4、TCP 的三次握手（为什么三次？）</strong></p><p><strong>5、TCP 的四次挥手（为什么四次？）</strong></p><p><strong>6、TCP 长连接和短连接的区别</strong></p><p><strong>7、TCP粘包、拆包及解决办法</strong></p><p><strong>8、TCP 可靠传输</strong></p><p><strong>9、TCP 滑动窗口</strong></p><p><strong>10、TCP 流量控制</strong></p><p><strong>11、TCP 拥塞控制</strong></p><p><strong>12、提供网络利用率</strong></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>网络层只把分组发送到目的主机，但是真正通信的并不是主机而是主机中的进程。传输层提供了进程间的逻辑通信，传输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看起来像是在两个传输层实体之间有一条端到端的逻辑通信信道。</p><p><strong>1、UDP 和 TCP 的特点与区别</strong></p><p><strong>用户数据报协议 UDP（User Datagram Protocol）</strong></p><p>是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。</p><p><strong>传输控制协议 TCP（Transmission Control Protocol）</strong></p><p>是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。</p><h2 id="2、UDP-、TCP-首部格式"><a href="#2、UDP-、TCP-首部格式" class="headerlink" title="2、UDP 、TCP 首部格式"></a><strong>2、UDP 、TCP 首部格式</strong></h2><p><img src="https://pic1.zhimg.com/80/v2-c01a6511abf81f867fd0e531bd51af2c_1440w.jpg" alt="UDP 首部格式"></p><p>UDP 首部字段只有 8 个字节，包括源端口、目的端口、长度、检验和。12 字节的伪首部是为了计算检验和临时添加的。</p><p><img src="https://pic3.zhimg.com/80/v2-3bd45a13afe868cae6225d75b85e9c36_1440w.jpg" alt="TCP 首部格式"></p><p>TCP 首部格式比 UDP 复杂。</p><p><strong>序号：</strong>用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。</p><p><strong>确认号：</strong>期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。</p><p><strong>数据偏移：</strong>指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。</p><p><strong>控制位：</strong>八位从左到右分别是 CWR，ECE，URG，ACK，PSH，RST，SYN，FIN。</p><p><strong>CWR：</strong>CWR 标志与后面的 ECE 标志都用于 IP 首部的 ECN 字段，ECE 标志为 1 时，则通知对方已将拥塞窗口缩小；</p><p><strong>ECE：</strong>若其值为 1 则会通知对方，从对方到这边的网络有阻塞。在收到数据包的 IP 首部中 ECN 为 1 时将 TCP 首部中的 ECE 设为 1；</p><p><strong>URG：</strong>该位设为 1，表示包中有需要紧急处理的数据，对于需要紧急处理的数据，与后面的紧急指针有关；</p><p><strong>ACK：</strong>该位设为 1，确认应答的字段有效，TCP规定除了最初建立连接时的 SYN 包之外该位必须设为 1；</p><p><strong>PSH：</strong>该位设为 1，表示需要将收到的数据立刻传给上层应用协议，若设为 0，则先将数据进行缓存；</p><p><strong>RST：</strong>该位设为 1，表示 TCP 连接出现异常必须强制断开连接；</p><p><strong>SYN：</strong>用于建立连接，该位设为 1，表示希望建立连接，并在其序列号的字段进行序列号初值设定；</p><p><strong>FIN：</strong>该位设为 1，表示今后不再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 FIN 位置为 1 的 TCP 段。</p><p>每个主机又对对方的 FIN 包进行确认应答之后可以断开连接。不过，主机收到 FIN 设置为 1 的 TCP 段之后不必马上回复一个 FIN 包，而是可以等到缓冲区中的所有数据都因为已成功发送而被自动删除之后再发 FIN 包；</p><p><strong>窗口：</strong>窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。</p><h2 id="3、什么是-TCP-的三次握手和四次挥手？"><a href="#3、什么是-TCP-的三次握手和四次挥手？" class="headerlink" title="3、什么是 TCP 的三次握手和四次挥手？"></a><strong>3、什么是 TCP 的三次握手和四次挥手？</strong></h2><p>TCP 是一种面向连接的单播协议，在发送数据前，通信双方必须在彼此间建立一条连接。所谓的“连接”，其实是客户端和服务器的内存里保存的一份关于对方的信息，如 IP 地址、端口号等。</p><p>TCP 可以看成是一种字节流，它会处理 IP 层或以下的层的丢包、重复以及错误问题。在连接的建立过程中，双方需要交换一些连接的参数。这些参数可以放在 TCP 头部。</p><p>TCP 提供了一种可靠、面向连接、字节流、传输层的服务，采用三次握手建立一个连接；采用四次挥手来关闭一个连接。</p><p>一个 TCP 连接由一个 4 元组构成，分别是两个 IP 地址和两个端口号。一个TCP连接通常分为三个阶段：启动、数据传输、退出（关闭）。</p><p>当 TCP 接收到另一端的数据时，它会发送一个确认，但这个确认不会立即发送，一般会延迟一会（提供网络利用率这部分有讲到）。</p><p>ACK 是累积的，一个确认字节号 N 的 ACK 表示所有直到 N 的字节（不包括 N）已经成功被接收了。这样的好处是如果一个 ACK 丢失，很可能后续的 ACK 就足以确认前面的报文段了。</p><p><strong>一个完整的 TCP 连接是双向和对称的，数据可以在两个方向上平等地流动。给上层应用程序提供一种双工服务。一旦建立了一个连接，这个连接的一个方向上的每个 TCP 报文段都包含了相反方向上的报文段的一个 ACK。</strong></p><p>序列号的作用是使得一个 TCP 接收端可丢弃重复的报文段，记录以杂乱次序到达的报文段。因为 TCP 使用 IP 来传输报文段，而IP 不提供重复消除或者保证次序正确的功能。</p><p>另一方面，TCP 是一个字节流协议，绝不会以杂乱的次序给上层程序发送数据。因此 TCP 接收端会被迫先保持大序列号的数据不交给应用程序，直到缺失的小序列号的报文段被填满。</p><h2 id="4、TCP-的三次握手（为什么三次？）"><a href="#4、TCP-的三次握手（为什么三次？）" class="headerlink" title="4、TCP 的三次握手（为什么三次？）"></a><strong>4、TCP 的三次握手（为什么三次？）</strong></h2><p>三次握手：</p><p><img src="https://pic4.zhimg.com/80/v2-0673bbc84fe4440aed9d1dadc67ae79b_1440w.jpg" alt="三次握手"></p><p>假设 A 为客户端，B 为服务器端。</p><p>首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。</p><ul><li>A 向 B 发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号 x。</li><li>B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。</li><li>A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。</li></ul><p>B 收到 A 的确认后，连接建立。</p><p><strong>为什么三次？</strong></p><p>1、第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。</p><p>2、换个易于理解的视角来看为什么要 3 次握手。</p><p>客户端和服务端通信前要进行连接，“3次握手”的作用就是双方都能明确自己和对方的收、发能力是正常的。</p><p>第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。</p><p>第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。从客户端的视角来看，我接到了服务端发送过来的响应数据包，说明服务端接收到了我在第一次握手时发送的网络包，并且成功发送了响应数据包，这就说明，服务端的接收、发送能力正常。而另一方面，我收到了服务端的响应数据包，说明我第一次发送的网络包成功到达服务端，这样，我自己的发送和接收能力也是正常的。</p><p>第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力，服务端的发送、接收能力是正常的。第一、二次握手后，服务端并不知道客户端的接收能力以及自己的发送能力是否正常。</p><p>而在第三次握手时，服务端收到了客户端对第二次握手作的回应。从服务端的角度，我在第二次握手时的响应数据发送出去了，客户端接收到了。所以，我的发送能力是正常的。而客户端的接收能力也是正常的。</p><p>经历了上面的三次握手过程，客户端和服务端都确认了自己的接收、发送能力是正常的。之后就可以正常通信了。</p><p><strong>每次都是接收到数据包的一方可以得到一些结论，发送的一方其实没有任何头绪。我虽然有发包的动作，但是我怎么知道我有没有发出去，而对方有没有接收到呢？</strong></p><p>而从上面的过程可以看到，最少是需要三次握手过程的。两次达不到让双方都得出自己、对方的接收、发送能力都正常的结论。</p><p>其实每次收到网络包的一方至少是可以得到：对方的发送、我方的接收是正常的。而每一步都是有关联的，下一次的“响应”是由于第一次的“请求”触发，因此每次握手其实是可以得到额外的结论的。</p><p>比如第三次握手时，服务端收到数据包，表明看服务端只能得到客户端的发送能力、服务端的接收能力是正常的，但是结合第二次，说明服务端在第二次发送的响应包，客户端接收到了，并且作出了响应，从而得到额外的结论：客户端的接收、服务端的发送是正常的。</p><h2 id="5、TCP-的四次挥手（为什么四次？）"><a href="#5、TCP-的四次挥手（为什么四次？）" class="headerlink" title="5、TCP 的四次挥手（为什么四次？）"></a><strong>5、TCP 的四次挥手（为什么四次？）</strong></h2><p>四次挥手：</p><p><strong><img src="https://pic2.zhimg.com/80/v2-8bf6f231cdd87b2613554f54424e8201_1440w.jpg" alt="四次挥手"></strong></p><ul><li>客户端发送一个 FIN 段，并包含一个希望接收者看到的自己当前的序列号 K. 同时还包含一个 ACK 表示确认对方最近一次发过来的数据。</li><li>服务端将 K 值加 1 作为 ACK 序号值，表明收到了上一个包。这时上层的应用程序会被告知另一端发起了关闭操作，通常这将引起应用程序发起自己的关闭操作。</li><li>服务端发起自己的 FIN 段，ACK=K+1, Seq=L。</li><li>客户端确认。进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。ACK=L+1。</li></ul><p><strong>为什么建立连接是三次握手，而关闭连接却是四次挥手呢？</strong></p><p>1、TCP连接是双向传输的对等的模式，就是说双方都可以同时向对方发送或接收数据。当有一方要关闭连接时，会发送指令告知对方，我要关闭连接了。</p><p><strong>2、这时对方会回一个ACK，此时一个方向的连接关闭。并不代表另一个方向也要关闭，另一个方向仍然可以继续传输数据，也就是说，服务端收到客户端的 FIN 标志，知道客户端想要断开这次连接了，但是，我服务端，我还想发数据呢？我等到发送完了所有的数据后，会发送一个 FIN 段来关闭此方向上的连接。接收方发送 ACK确认关闭连接。</strong></p><p>注意，接收到FIN报文的一方只能回复一个ACK, 它是无法马上返回对方一个FIN报文段的，因为结束数据传输的“指令”是上层应用层给出的，我只是一个“搬运工”，我无法了解“上层的意志”。</p><p>3、客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。</p><p>4、因为服务端在 LISTEN 状态下，收到建立连接请求的 SYN 报文后，把 ACK 和 SYN 放在一个报文里发送给客户端。而关闭连接时，当收到对方的 FIN 报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方是否现在关闭发送数据通道，需要上层应用来决定，因此，己方 ACK 和 FIN 一般都会分开发。</p><p><strong>TIME_WAIT</strong></p><p>客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：</p><ul><li>确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。</li><li>等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。</li></ul><h2 id="6、TCP-短连接和长连接的区别"><a href="#6、TCP-短连接和长连接的区别" class="headerlink" title="6、TCP 短连接和长连接的区别"></a><strong>6、TCP 短连接和长连接的区别</strong></h2><p><strong>短连接：</strong>Client 向 Server 发送消息，Server 回应 Client，然后一次读写就完成了，这时候双方任何一个都可以发起 close 操作，不过一般都是 Client 先发起 close 操作。短连接一般只会在 Client/Server 间传递一次读写操作。</p><p>短连接的优点：管理起来比较简单，建立存在的连接都是有用的连接，不需要额外的控制手段。</p><p><strong>长连接：</strong>Client 与 Server 完成一次读写之后，它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个连接。</p><p>在长连接的应用场景下，Client 端一般不会主动关闭它们之间的连接，Client 与 Server 之间的连接如果一直不关闭的话，随着客户端连接越来越多，Server 压力也越来越大，这时候 Server 端需要采取一些策略，如关闭一些长时间没有读写事件发生的连接，这样可以避免一些恶意连接导致 Server 端服务受损；如果条件再允许可以以客户端为颗粒度，限制每个客户端的最大长连接数，从而避免某个客户端连累后端的服务。</p><p>长连接和短连接的产生在于 Client 和 Server 采取的关闭策略，具体的应用场景采用具体的策略。</p><h2 id="7、TCP粘包、拆包及解决办法"><a href="#7、TCP粘包、拆包及解决办法" class="headerlink" title="7、TCP粘包、拆包及解决办法"></a><strong>7、TCP粘包、拆包及解决办法</strong></h2><p><strong>为什么常说 TCP 有粘包和拆包的问题而不说 UDP ？</strong></p><p>由前两节可知，UDP 是基于报文发送的，UDP首部采用了 16bit 来指示 UDP 数据报文的长度，因此在应用层能很好的将不同的数据报文区分开，从而避免粘包和拆包的问题。</p><p>而 TCP 是基于字节流的，虽然应用层和 TCP 传输层之间的数据交互是大小不等的数据块，但是 TCP 并没有把这些数据块区分边界，仅仅是一连串没有结构的字节流；另外从 TCP 的帧结构也可以看出，在 TCP 的首部没有表示数据长度的字段，基于上面两点，在使用 TCP 传输数据时，才有粘包或者拆包现象发生的可能。</p><p><strong>什么是粘包、拆包？</strong></p><p>假设 Client 向 Server 连续发送了两个数据包，用 packet1 和 packet2 来表示，那么服务端收到的数据可以分为三种情况，现列举如下：</p><p>第一种情况，接收端正常收到两个数据包，即没有发生拆包和粘包的现象。</p><p><img src="https://pic2.zhimg.com/80/v2-1f03c5a6c04279d9c318ef48348dc32d_1440w.png" alt="one"></p><p>第二种情况，接收端只收到一个数据包，但是这一个数据包中包含了发送端发送的两个数据包的信息，这种现象即为粘包。这种情况由于接收端不知道这两个数据包的界限，所以对于接收端来说很难处理。</p><p><img src="https://pic3.zhimg.com/80/v2-e090a51ff37d6dfd1de747c70288222a_1440w.png" alt="two"></p><p>第三种情况，这种情况有两种表现形式，如下图。接收端收到了两个数据包，但是这两个数据包要么是不完整的，要么就是多出来一块，这种情况即发生了拆包和粘包。这两种情况如果不加特殊处理，对于接收端同样是不好处理的。</p><p><img src="https://pic2.zhimg.com/80/v2-6163805a4cbd6be0581cca82cd5ac8f5_1440w.png" alt="three"></p><p><img src="https://pic2.zhimg.com/80/v2-ca1d6c986cec845951dd0811f5888021_1440w.png" alt="img"></p><p><strong>为什么会发生 TCP 粘包、拆包？</strong></p><ul><li>要发送的数据大于 TCP 发送缓冲区剩余空间大小，将会发生拆包。</li><li>待发送数据大于 MSS（最大报文长度），TCP 在传输前将进行拆包。</li><li>要发送的数据小于 TCP 发送缓冲区的大小，TCP 将多次写入缓冲区的数据一次发送出去，将会发生粘包。</li><li>接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包。</li></ul><p><strong>粘包、拆包解决办法</strong></p><p>由于 TCP 本身是面向字节流的，无法理解上层的业务数据，所以在底层是无法保证数据包不被拆分和重组的，这个问题只能通过上层的应用协议栈设计来解决，根据业界的主流协议的解决方案，归纳如下：</p><ul><li><strong>消息定长：</strong>发送端将每个数据包封装为固定长度（不够的可以通过补 0 填充），这样接收端每次接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来。</li><li><strong>设置消息边界：</strong>服务端从网络流中按消息边界分离出消息内容。在包尾增加回车换行符进行分割，例如 FTP 协议。</li><li><strong>将消息分为消息头和消息体：</strong>消息头中包含表示消息总长度（或者消息体长度）的字段。</li><li>更复杂的应用层协议比如 Netty 中实现的一些协议都对粘包、拆包做了很好的处理。</li></ul><h2 id="8、TCP-可靠传输"><a href="#8、TCP-可靠传输" class="headerlink" title="8、TCP 可靠传输"></a><strong>8、TCP 可靠传输</strong></h2><p>TCP 使用超时重传来实现可靠传输：如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。</p><p>一个报文段从发送再到接收到确认所经过的时间称为往返时间 RTT，加权平均往返时间 RTTs 计算如下：</p><p><img src="https://pic1.zhimg.com/80/v2-c55cbe9732b1a2bf9b13e63bb489a650_1440w.png" alt="RTTs"></p><p>其中，0 ≤ a ＜ 1，RTTs 随着 a 的增加更容易受到 RTT 的影响。超时时间 RTO 应该略大于 RTTs，TCP 使用的超时时间计算如下：</p><p><img src="https://pic1.zhimg.com/80/v2-7b92eb20e4b0fb7f0a471a06806239a8_1440w.jpg" alt="RTO"></p><p>其中 RTTd 为偏差的加权平均值。</p><h2 id="9、TCP-滑动窗口"><a href="#9、TCP-滑动窗口" class="headerlink" title="9、TCP 滑动窗口"></a><strong>9、TCP 滑动窗口</strong></h2><p>窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。</p><p>发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。</p><p>接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31} 按序到达，而 {34, 35} 就不是，因此只对字节 31 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。</p><p><img src="https://pic4.zhimg.com/80/v2-b9535beef75cdd742cb5718f97029a6f_1440w.jpg" alt="滑动窗口"></p><h2 id="10、TCP-流量控制"><a href="#10、TCP-流量控制" class="headerlink" title="10、TCP 流量控制"></a><strong>10、TCP 流量控制</strong></h2><p>流量控制是为了控制发送方发送速率，保证接收方来得及接收。</p><p>接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</p><p><strong>实际上，为了避免此问题的产生，发送端主机会时不时的发送一个叫做窗口探测的数据段</strong>，此数据段仅包含一个字节来获取最新的窗口大小信息。</p><h2 id="11、TCP-拥塞控制"><a href="#11、TCP-拥塞控制" class="headerlink" title="11、TCP 拥塞控制"></a><strong>11、TCP 拥塞控制</strong></h2><p>如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。</p><p><img src="https://pic4.zhimg.com/80/v2-62529f3bda992dc7035dcb13ef0da8b7_1440w.jpg" alt="拥塞控制"></p><p>TCP 主要通过四个算法来进行拥塞控制：</p><p><strong>慢开始、拥塞避免、快重传、快恢复。</strong></p><p>发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。</p><p>为了便于讨论，做如下假设：</p><ul><li>接收方有足够大的接收缓存，因此不会发生流量控制；</li><li>虽然 TCP 的窗口基于字节，但是这里设窗口的大小单位为报文段。</li></ul><p><img src="https://pic1.zhimg.com/80/v2-a62edcee3fb47ed147e56bdc8001feec_1440w.jpg" alt="窗口变化"></p><p><strong>慢开始与拥塞避免</strong></p><p>发送的最初执行慢开始，令 cwnd = 1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 …</p><p>注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。设置一个慢开始门限 ssthresh，当 cwnd &gt;= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。</p><p>如果出现了超时，则令 ssthresh = cwnd / 2，然后重新执行慢开始。</p><p><strong>快重传与快恢复</strong></p><p>在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。</p><p>在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3。</p><p>在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。</p><p>慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。</p><p><img src="https://pic2.zhimg.com/80/v2-1cc37f757263f3cd58e917059cedc7b5_1440w.jpg" alt="快重传"></p><h2 id="12、提供网络利用率"><a href="#12、提供网络利用率" class="headerlink" title="12、提供网络利用率"></a><strong>12、提供网络利用率</strong></h2><p><strong>1、Nagle 算法</strong></p><p>发送端即使还有应该发送的数据，但如果这部分数据很少的话，则进行延迟发送的一种处理机制。具体来说，就是仅在下列任意一种条件下才能发送数据。如果两个条件都不满足，那么暂时等待一段时间以后再进行数据发送。</p><ul><li>已发送的数据都已经收到确认应答。</li><li>可以发送最大段长度的数据时。</li></ul><p><strong>2、延迟确认应答</strong></p><p>接收方收到数据之后可以并不立即返回确认应答，而是延迟一段时间的机制。</p><ul><li>在没有收到 2*最大段长度的数据为止不做确认应答。</li><li>其他情况下，最大延迟 0.5秒 发送确认应答。</li><li>TCP 文件传输中，大多数是每两个数据段返回一次确认应答。</li></ul><p><strong>3、捎带应答</strong></p><p>在一个 TCP 包中既发送数据又发送确认应答的一种机制，由此，网络利用率会提高，计算机的负荷也会减轻，但是这种应答必须等到应用处理完数据并将作为回执的数据返回为止。</p><p>今天的知识点掌握了吗？不要忘了学而时习之，不亦可乎。</p><p>各位老铁们如果有补充的，也是可以留言区补充一波哦。</p><blockquote><p>参考：</p><p><a href="https://link.zhihu.com/?target=http%3A//www.cnblogs.com/panchanggui/p/9518735.html">http://www.cnblogs.com/panchanggui/p/9518735.html</a></p><p><a href="https://link.zhihu.com/?target=http%3A//www.cnblogs.com/qcrao-2018/p/10182185.html">http://www.cnblogs.com/qcrao-2018/p/10182185.html</a></p><p><a href="https://link.zhihu.com/?target=http%3A//github.com/CyC2018/CS-Notes/blob/master/docs/notes/">http://github.com/CyC2018/CS-Notes/blob/master/docs/notes/</a></p></blockquote><h3 id="—极客时间专栏分享—"><a href="#—极客时间专栏分享—" class="headerlink" title="—极客时间专栏分享—"></a>—极客时间专栏分享—</h3><p>上面这篇文章参考了很多的书籍，对了，还有一些我认为非常不错的高质量专栏。</p><p>对于计算机网络的学习，我相信大家一开始都会觉得这里面的知识太多太杂，容易摸不着头脑，这里呢，我给大家分享一个极客时间的专栏福利，跟之前推荐的《趣学Linux操作系统》是同一个老师哦，学起来很有趣，而且每一篇后面都会有很多精彩的留言，老师讲的非常不错，而且每一篇文章老师都亲自录音文字稿，方便大家在通勤路上也可以用耳机学习，真的很良心了，文章通俗易懂又饶有趣味，真诚的推荐给各位老铁们，有需要的可以扫码加入，一起学习，一起加油！</p><p>（感觉极客时间很多专栏都写的挺不错哦，如果不是真心感觉不错的我也不会随便推荐的）。</p><div align="center"> <img src="https://pic4.zhimg.com/80/v2-03a9b4750f686a50ca6374d309757a1f_1440w.jpg"width="300"/> </div><br><br/><blockquote><ul><li>本文已收录至我的 GitHub 程序员成长系列【MoreThanCode】 ，欢迎 star：<a href="https://github.com/rongweihe/MoreThanCode" target="_blank" rel="noopener">https://github.com/rongweihe/MoreThanCode</a></li><li><strong>个人公众号</strong> ：herongwei，<strong>个人独立域名博客</strong>：herongwei.com，坚持原创输出，下方扫码关注，2020，与您共同成长！</li></ul></blockquote><div align="center"> <img src="https://i.loli.net/2020/04/11/GquzYyQ5loDCALM.png"width="500"/> </div><br><p>非常感谢各位老铁能 <strong>看到这里</strong>，如果觉得本篇文章写得不错，觉得 <strong>「herongwei」是一个认真的仔</strong> 的话，<strong>求点赞，求关注，求分享，求留言哦！</strong></p><p>创作不易，各位老铁的支持和认可，就是我创作的最大动力，我们下篇文章在见！</p>]]></content>
      
      
      <categories>
          
          <category> 计算机知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
            <tag> 计算机网络 </tag>
            
            <tag> 底层知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈程序的内存布局</title>
      <link href="/2020/04/11/qian-tan-cheng-xu-de-nei-cun-bu-ju/"/>
      <url>/2020/04/11/qian-tan-cheng-xu-de-nei-cun-bu-ju/</url>
      
        <content type="html"><![CDATA[<h5 id="前言："><a href="#前言：" class="headerlink" title="前言："></a><strong>前言</strong>：</h5><blockquote><p>原文首发于知乎：<a href="https://zhuanlan.zhihu.com/p/77122692" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/77122692</a></p><p>目前收获 388+ 个赞，20+ 评论。</p></blockquote><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><blockquote><p><strong>1、什么是 User space 与 Kernel space？</strong></p><p><strong>2、Linux 下一个进程里典型的内存布局是怎样的？</strong></p><p><strong>3、什么是栈区？</strong></p><p><strong>4、什么是堆区？</strong></p><p><strong>5、malloc 算法是如何实现的？</strong></p><p><strong>6、Linux 系统下，有几种堆空间分配方式？</strong></p></blockquote><p><strong>上面几个问题，点进来的老铁，心里有答案吗？如果没有，跟我一起来探究一下吧。</strong></p><h2 id="1、User-space-与-Kernel-space"><a href="#1、User-space-与-Kernel-space" class="headerlink" title="1、User space 与 Kernel space"></a><strong>1、User space 与 Kernel space</strong></h2><p>现代的应用程序都运行在一个内存空间里，在 32 位系统中，这个内存空间拥有 4GB （2 的 32 次方）的寻址能力。</p><p>尽管现在的内存空间都号称是平坦的，但实际上内存仍然在不同的地址区间有着不同的地位，例如，大多数操作系统都会将 4GB 的内存空间一部分挪给内核使用，应用程序无法直接访问这一段内存，这一部分内存地址被称为 内核空间。</p><blockquote><p>Windows 在默认的情况下会将高地址的 2GB 空间分配给内核（也可以配置 1GB）。<br>Linux 默认情况下将高地址的 1GB 空间分配给内核。</p></blockquote><p>用户使用的剩下的 2GB 或 3GB 的内存空间称为用户空间。</p><p><strong>为什么要区分内核空间和用户空间？</strong></p><p>大致有三点因素：</p><p>第一点：操作系统的数据都是存放于系统空间的，用户进程的数据是存放于用户空间的；</p><p>第二点：分开来存放，就让系统的数据和用户的数据互不干扰，保证系统的稳定性，并且管理上很方便；</p><p>第三点：也是重要的一点，将用户的数据和系统的数据隔离开，就可以对两部分的数据的访问进行控制。这样就可以确保用户程序不能随便操作系统的数据，这样防止用户程序误操作或者是恶意破坏系统。</p><p>下面这一张图，比较形象的解释了 User space 与 Kernel space 的区别</p><p><img src="https://pic2.zhimg.com/80/v2-18fabec59a3f38e36a371caa5d1093a9_1440w.jpg" alt="User space VS Kernel space"></p><p>简单说，Kernel space 是 Linux 内核的运行空间，User space 是用户程序的运行空间。为了安全，它们是隔离的，即使用户的程序崩溃了，内核也不受影响。</p><p>Kernel space 可以执行任意命令，调用系统的一切资源；</p><p>相对来说，User space 执行的是较为简单的运算，执行的运算不影响其他程序的执行，并且不能直接调用系统资源，必须通过系统接口（又称 system call），才能向内核发出指令。</p><blockquote><p>这里补充下知乎网友@风云评论：<br>其实，在用户空间，几乎所有内核资源在用户空间都是可以访问的（必须有相应的权限），即使是操作系统内核的大脑（调度程序）。</p></blockquote><p>在用户空间里，也有许多地址区间有特权的地位，一般来讲，应用程序使用的内存空间里有如下“默认”的区域。</p><blockquote><p><strong>栈：</strong> 栈用于维护函数调用的上下文，离开了栈，函数调用就无法实现，栈通常在用户空间的最高地址处分配，通常有数兆字节的大小。</p><p><strong>堆：</strong> 堆是用来容纳应用程序动态分配的内存区域，当程序使用 malloc 或者 new 分配内存的时候，得到的内存会来自堆里。堆通常存在栈的下方（低地址方向），在某些时候，堆也可能没有固定统一的存储区域。堆一般比栈大很多，可以有几十至数百兆字节的容量。</p><p><strong>可执行文件映像：</strong> 存储着可执行文件在内存里的映像，由装载器在装载时将可执行文件的内存读取或映射到这里。</p><p><strong>保留区：</strong> 保留区并不是一个单一的内存区域，而是对内存中受到保护而禁止访问的内存区域的总称：例如大多数操作系统中，极小的地址通常都是不允许访问的，如 NULL，C 语言将无效指针赋值为 0 也是这个考虑。</p><p><strong>动态链接库映射区：</strong> 这个区域用于映射装载的动态链接库。在 Linux 下，如果可执行文件依赖其它共享库，那么系统就会为它在从 0x40000000 开始的地址分配相应的空间，并将共享库载入该空间。<br>剩下的还有以下几部份组成：<br>（1）代码段<br>（2）初始化数据段（数据段）<br>（3）未初始化数据段（BSS 段）</p></blockquote><p>下图是 Linux 下一个进程里典型的内存布局</p><p><img src="https://pic1.zhimg.com/80/v2-d208651aa87138e6291d789b3a880444_1440w.jpg" alt="Linux 下一个进程里典型的内存布局"></p><p>图中的箭头，标明了几个大小可变的尺寸增长的方向，在这里，可以清晰地看出</p><blockquote><p><strong>栈是由高地址向低地址增长。</strong><br><strong>堆是由低地址向高地址增长。</strong></p></blockquote><p>当栈或堆现有的大小不够用的时候，它将按照图中的增长方向扩大自身的尺寸，直到预留的空间被用完为止。</p><p>在讲堆和栈之前，我们先来看一下代码段，初始化数据段和未初始化数据段。</p><h2 id="2、代码段"><a href="#2、代码段" class="headerlink" title="2、代码段"></a><strong>2、代码段</strong></h2><p>代码段中存放可执行的指令，在内存中，为了保证不会因为堆栈溢出被覆盖，将其放在了堆栈段下面（从上图可以看出）。通常来讲代码段是共享的，这样多次反复执行的指令只需要在内存中驻留一个副本即可，比如 C 编译器，文本编辑器等。代码段一般是只读的，程序执行时不能随意更改指令，也是为了进行隔离保护。</p><h2 id="3、初始化数据段"><a href="#3、初始化数据段" class="headerlink" title="3、初始化数据段"></a><strong>3、初始化数据段</strong></h2><p>初始化数据段有时就称之为数据段。数据段是一个程序虚拟地址空间的一部分，包括一全局变量和静态变量，这些变量在编程时就已经被初始化。数据段是可以修改的，不然程序运行时变量就无法改变了，这一点和代码段不同。</p><p>数据段可以细分为初始化只读区和初始化读写区。这一点和编程中的一些特殊变量吻合。比如全局变量 int global n = 1就被放在了初始化读写区，因为 global 是可以修改的。而 const int m = 2 就会被放在只读区，很明显，m 是不能修改的。</p><h2 id="4、未初始化数据段"><a href="#4、未初始化数据段" class="headerlink" title="4、未初始化数据段"></a><strong>4、未初始化数据段</strong></h2><p>未初始化数据段有时称之为 BSS 段，BSS 是英文 Block Started by Symbol 的简称，BSS 段属于静态内存分配。存放在这里的数据都由内核初始化为 0。未初始化数据段从数据段的末尾开始，存放有全部的全局变量和静态变量并被，默认初始化为 0，或者代码中没有显式初始化。比如 static int i; 或者全局 int j; 都会被放到BSS段。</p><h2 id="5、栈"><a href="#5、栈" class="headerlink" title="5、栈"></a><strong>5、栈</strong></h2><p> 栈 (stack) 是现代计算机程序里最为重要的概念之一，几乎每一个程序都使用了栈，没有栈就没有函数，没有局部变量，也就没有我们如今能够看见的所有的计算机语言。在解释为什么栈会如此重要之前，让我们来先了解一下传统的栈的定义：</p><p> 在经典的计算机科学中，栈被定义为一个特殊的容器，用户可以将数据压入栈中(入栈,push，也可以将已经压入栈中的数据弹出(出栈, pop)，但栈这个容器必须遵守一条规则：先入栈的数据后出栈(First In Last Out, FIFO)，多多少少像叠成一叠的书：先叠上去的书在最下面：因此要最后才能取出。</p><p> 在计算机系统中，栈则是一个具有以上属性的动态内存区域。程序可以将数据压入栈中,也可以将数据从栈顶弹出。压栈操作使得栈增大,而弹出操作使栈减小。</p><p> 在经典的操作系统里，栈总是向下增长的。</p><p><strong>在i386下，栈顶由称为 esp 的寄存器进行定位。压栈的操作使栈顶的地址减小，弹出的操作使栈顶地址增大。</strong></p><p><img src="https://pic1.zhimg.com/80/v2-c80a937e5d09461436c68d3357c46fc4_1440w.jpg" alt="栈的实例"></p><p>这里栈底的地址是 0xbffff，而 esp 寄存器标明了栈顶，地址为 0xbifff4。</p><p>在栈上压入数据会导致 esp 减小，弹出数据使得 esp 增大。</p><p>栈在程序运行中具有举足轻重的地位。最重要的，栈保存了一个函数调用所需要的维护信息，这常常被称为堆栈帧(Stack Frame)或活动记录(Activate Record)，堆栈帧一般包括如下几方面内容：</p><blockquote><p><strong>1、函数的返回地址和参数。</strong><br><strong>2、临时变量:包括函数的非静态局部变量以及编译器自动生成的其他临时变量。</strong><br><strong>3、保存的上下文:包括在函数调用前后需要保持不变的寄存器。</strong></p></blockquote><h2 id="6、堆"><a href="#6、堆" class="headerlink" title="6、堆"></a><strong>6、堆</strong></h2><p>相对于栈，堆这片内存面临着一个稍微复杂的行为模式：在任意时刻，程序可能发出请求，要么申请一段内存，要么释放一段已经申请过的内存，而且申请的大小从几个字节到数 GB 都是有可能的，我们不能假设程序会一次申请多少堆空间，因此，堆的管理显得较为复杂。</p><p><strong>为什么需要堆？</strong></p><blockquote><p>光有栈，对于面向过程的程序设计还远远不够，因为栈上的数据在函数返回的时候就会被释放掉，所以无法将数据传递至函数外部。而全局变量没有办法动态地产生，只能在编译的时候定义，有很多情况下缺乏表现力，在这种情况下，堆（Heap）是一种唯一的选择。</p></blockquote><p>堆是一款巨大的内存空间，常常占据整个虚拟空间的绝大部分，在这片空间里，程序可以请求一块连续的内存，并自由地使用，这块内存在程序主动放弃之前都活一直保持有效，下面是一个申请堆空间最简单的例子：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">char</span><span class="token operator">*</span> p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">233</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在第 3 行用 malloc 申请了 233 个字节的空间之后，程序可以自由地使用这 233个字节，直到程序用free函数释放它。</p><p><strong>那么 malloc 到底是怎么实现的呢？</strong></p><p>有一种做法是，把进程的内存管理交给操作系统内核去做，既然内核管理着进程的地址空间，那么如果它提供一个系统调用，可以让程序使用这个系统调用申请内存，不就可以了吗？</p><p>当然这是一种理论上可行的做法，但实际上这样做的性能比较差，原因在于每次程序申请或者释放堆空间都需要进行系统调用。</p><p>我们知道系统调用的性能开销是很大的，当程序对堆的操作比较频繁时，这样做的结果是会严重影响程序的性能的。</p><p><strong>比较好的做法就是：程序向操作系统申请一块适当大小的堆空间，然后由程序自己管理这块空间，而具体来讲，管理着堆空间分配的往往是程序的运行库。</strong></p><p>运行库相当于是向操作系统 <strong>“批发”</strong> 了一块较大的堆空间，然后 “零售” 给程序用。</p><p>当全部“售完”或程序有大量的内存需求时，再根据实际需求向操作系统“进货”。</p><p>当然运行库在向程序零售堆空间时，必须管理它批发来的堆空间，不能把同一块地址出售两次，导致地址的冲突。</p><h2 id="7、Linux-进程堆管理"><a href="#7、Linux-进程堆管理" class="headerlink" title="7、Linux 进程堆管理"></a><strong>7、Linux 进程堆管理</strong></h2><p>由第一节可知，进程的地址空间中，除了可执行文件，共享库和栈之外，剩余的未分配的空间都可以用来作为堆空间。</p><p>Linux 系统下，提供两种堆空间分配方式，两个系统调用：brk() 系统调用 和 mmap() 系统调用</p><p>这两种方式分配的都是虚拟内存，没有分配物理内存。在第一次访问已分配的虚拟地址空间的时候，发生缺页中断，操作系统负责分配物理内存，然后建立虚拟内存和物理内存之间的映射关系。</p><p>在标准 C 库中，提供了malloc/free函数分配释放内存，这两个函数底层是由 brk，mmap，munmap 这些系统调用实现的。</p><h3 id="brk-系统调用"><a href="#brk-系统调用" class="headerlink" title="brk() 系统调用"></a><strong>brk() 系统调用</strong></h3><blockquote><p>C 语言形式声明：int brk() {void* end_data_segment;}<br>brk() 的作用实际上就是设置进程数据段的结束地址，即它可以扩大或者缩小数据段（Linux 下数据段和 BBS 合并在一起统称数据段）。<br>如果我们将数据段的结束地址向高地址移动，那么扩大的那部分空间就可以被我们使用，把这块空间拿过来使用作为堆空间是最常见的做法。</p></blockquote><h3 id="mmap-系统调用"><a href="#mmap-系统调用" class="headerlink" title="mmap() 系统调用"></a><strong>mmap() 系统调用</strong></h3><blockquote><p>和 Windows 系统下的 VirtualAlloc 很相似，它的作用就是向操作系统申请一段虚拟地址空间，（堆和栈中间，称为文件映射区域的地方）这块虚拟地址空间可以映射到某个文件。<br>glibc 的 malloc 函数是这样处理用户的空间请求的：对于小于 128KB 的请求来说，它会在现有的堆空间里面，按照堆分配算法为它分配一块空间并返回；对于大于128KB 的请求来说，它会使用 mmap() 函数为它分配一块匿名空间，然后在这个匿名空间中为用户分配空间。</p></blockquote><p>声明如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span><span class="token operator">*</span> mmap<span class="token punctuation">{</span>    <span class="token keyword">void</span><span class="token operator">*</span> start<span class="token punctuation">;</span>    size_t length<span class="token punctuation">;</span>    <span class="token keyword">int</span> prot<span class="token punctuation">;</span>    <span class="token keyword">int</span> flags<span class="token punctuation">;</span>    <span class="token keyword">int</span> fd<span class="token punctuation">;</span>    off_t offset<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>mmap 前两个参数分别用于指定需要申请的空间的起始地址和长度，如果起始地址设置 0，那么 Linux 系统会自动挑选合适的起始地址。<br>prot/flags 参数：用于设置申请的空间的权限（可读，可写，可执行）以及映射类型（文件映射，匿名空间等）。<br>最后两个参数用于文件映射时指定的文件描述符和文件偏移的。</p></blockquote><p>了解了 Linux 系统对于堆的管理之后，可以再来详细这么一个问题，那就是 malloc 到底一次能够申请的最大空间是多少？</p><p>为了回答这个问题，就不得不再回头仔细研究一下之前的图一。我们可以看到在有共享库的情况下，留给堆可以用的空间还有两处。第一处就是从 BSS 段结束到 0x40 000 000 即大约 1GB 不到的空间；</p><p>第二处是从共享库到栈的这块空间，大约是 2GB 不到。这两块空间大小都取决于栈、共享库的大小和数量。</p><p>于是可以估算到 malloc 最大的申请空间大约是 2GB 不到。（Linux 内核 2.4 版本）。</p><p>还有其它诸多因素会影响 malloc 的最大空间大小，比如系统的资源限制（ulimit），物理内存和交换空间的总和等。mmap 申请匿名空间时，系统会为它在内存或交换空间中预留地址，但是申请的空间大小不能超过空闲内存+空闲交换空间的总和。</p><h3 id="堆分配算法"><a href="#堆分配算法" class="headerlink" title="堆分配算法"></a>堆分配算法</h3><blockquote><p>1、空闲链表法（即调用 malloc 分配）：<br>就是把堆中各个空闲的块按照链表的方式连接起来，当用户请求一块空间的时候，可以遍历整个列表，直到找到合适大小的块并且将它拆分；当用户释放空间的时候将它合并到空闲链表中。<br>空闲链表是这样一种结构，在堆里的每一个空闲空间的开头(或结尾)有一个头 (header)，头结构里记录了上一个 (prev) 和下一个 (next) 空闲块的地址，也就是说，所有的空闲块形成了一个链表。如图所示。</p></blockquote><p><img src="https://pic3.zhimg.com/80/v2-2ec61852d2b6fccaf11fd92923a2d81e_1440w.jpg" alt="空闲链表法"></p><p>具体实现方案：</p><blockquote><p>1）malloc 函数的实质是它有一个将可用的内存块连接为一个长长的列表的所谓空闲链表。</p><p>2）调用 malloc（）函数时，它沿着连接表寻找一个大到足以满足用户请求所需要的内存块。然后，将该内存块一分为二（一块的大小与用户申请的大小相等，另一块的大小就是剩下来的字节）。接下来，将分配给用户的那块内存存储区域传给用户，并将剩下的那块（如果有的话）返回到连接表上。</p><p>3）调用 free 函数时，它将用户释放的内存块连接到空闲链表上。</p><p>4）到最后，空闲链会被切成很多的小内存片段，如果这时用户申请一个大的内存片段， 那么空闲链表上可能没有可以满足用户要求的片段了。于是，malloc() 函数请求延时，并开始在空闲链表上检查各内存片段，对它们进行内存整理，将相邻的小空闲块合并成较大的内存块。</p></blockquote><p>2、位图法</p><blockquote><p>针对空闲链表的弊端，另一种分配方式显得更加稳健。这种方式称为位围(Bitmap)，其核心思想是将整个堆划分为大量的块(block)，每个块的大小相同。</p><p>当用户请求内存的时候，总是分配整数个块的空间给用户，第一个块我们称为已分配区域的头(Head)，其余的称为己分配区域的主体(Body)，而我们可以使用一个整数数组来记录块的使用情况，由于每个块只有头/主体/空闲三种状态，因此仅仅需要两位即可表示一个块，因此称为位图。</p></blockquote><p>3、对象池</p><blockquote><p>还有一种方法是对象池，也是把堆空间分成了大小相等的一些块，它是认为某些场合每次分配的空间都相等，所以每次就直接返回一个块的大小，它的管理方法可以是链表也可以是位图。因为不用每次查找合适的大小的内存返回，所以效率很高。</p></blockquote><p>实际上很多现实应用中，堆的分配算法往往是采取多种算法复合而成的。</p><p>比如对于 glibc 来说，它对于小于 64 字节的空间申请是采用类似于对象池的方法；</p><p>而对于大于 512 字节的空间申请采用的是最佳适配算法；对于大于 64 字节而小于 512 字节的，它会根据情况采取上述方法中的最佳折中策略；对于大于 128KB 的申请，它会使用mmap 机制直接向操作系统申请空间。</p><blockquote><p>参考资料：</p><p>《程序员的自我修养》；《Linux 内核设计与实现》；《C primer plus 第6版中文版》。</p></blockquote><h3 id="——————————极客时间专栏分享————————–"><a href="#——————————极客时间专栏分享————————–" class="headerlink" title="——————————极客时间专栏分享————————–"></a>——————————极客时间专栏分享————————–</h3><p>上面这篇文章参考了很多的书籍，对了，还有一些我认为非常不错的高质量专栏。</p><p>对于操作系统的学习，我相信大家一开始都会觉得这里面的知识太多太杂，容易摸不着头脑，这里呢，我给大家分享一个极客时间的专栏福利，学了之后，我个人觉得极客时间上写得最好的一个专栏之一，学起来真的很有趣，而且每一篇后面都会有很多精彩的留言，老师讲的非常不错，而且每一篇文章老师都亲自录音文字稿，方便大家在通勤路上也可以用耳机学习，真的很良心了，文章通俗易懂又饶有趣味，真诚的推荐给各位老铁们，有需要的可以扫码加入，一起学习，一起加油！</p><p>（感觉极客时间很多专栏都写的挺不错哦，如果不是真心感觉不错的我也不会随便推荐的）。</p><div align="center"> <img src="https://i.loli.net/2020/04/11/JRGCZbIWwKd7Q4f.jpg"width="300"/> </div><br><div align="center"> <img src="https://i.loli.net/2020/04/11/q856p97RhmGM3lI.jpg"width="300"/> </div><br/><blockquote><ul><li>本文已收录至我的 GitHub 程序员成长系列【MoreThanCode】 ，欢迎 star：<a href="https://github.com/rongweihe/MoreThanCode" target="_blank" rel="noopener">https://github.com/rongweihe/MoreThanCode</a></li><li><strong>个人公众号</strong> ：herongwei，<strong>个人独立域名博客</strong>：herongwei.com，坚持原创输出，下方扫码关注，2020，与您共同成长！</li></ul></blockquote><div align="center"> <img src="https://i.loli.net/2020/04/11/GquzYyQ5loDCALM.png"width="500"/> </div><br><p>非常感谢各位老铁能<strong>看到这里</strong>，如果觉得本篇文章写得不错，觉得 <strong>「herongwei」是一个认真的仔</strong> 的话，<strong>求点赞，求关注，求分享，求留言哦！</strong></p><p>创作不易，各位老铁的支持和认可，就是我创作的最大动力，我们下篇文章在见！</p>]]></content>
      
      
      <categories>
          
          <category> 计算机知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
            <tag> 底层知识 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最新！多交的税可以退，同学，你今天退税了吗？</title>
      <link href="/2020/04/11/zui-xin-duo-jiao-de-shui-ke-yi-tui-tong-xue-ni-jin-tian-tui-shui-liao-ma/"/>
      <url>/2020/04/11/zui-xin-duo-jiao-de-shui-ke-yi-tui-tong-xue-ni-jin-tian-tui-shui-liao-ma/</url>
      
        <content type="html"><![CDATA[<p>原文首发于知乎：<a href="https://zhuanlan.zhihu.com/p/100766337" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/100766337</a></p><h5 id="4-10-号-更新"><a href="#4-10-号-更新" class="headerlink" title="4.10 号 更新"></a>4.10 号 更新</h5><p>1、有同学留言，已经收到退税了。</p><p>2、部分地区陆续开放申报了，建议大家不要着急。</p><p>3、大家耐心一点，该是你的一分不会少，退税这个事多退少补，建议大家在白天上班时间去APP上看看，毕竟相关公务人员也是正常上班（记得申报之前先登录！）</p><p>4、提前完善个人信息，包括绑定个人银行卡。</p><p>PS：我个人的申请已经到国库处理中这个状态了（已经处理快一个礼拜了，还在处理中。。嘤嘤嘤）。</p><h2 id="申报步骤：不要点申诉！不要着急，跟着我一步步来"><a href="#申报步骤：不要点申诉！不要着急，跟着我一步步来" class="headerlink" title="申报步骤：不要点申诉！不要着急，跟着我一步步来"></a>申报步骤：不要点<strong>申诉！</strong>不要着急，跟着我一步步来</h2><h3 id="1、第一步：下载-“个人所得税”-APP"><a href="#1、第一步：下载-“个人所得税”-APP" class="headerlink" title="1、第一步：下载 “个人所得税” APP"></a>1、第一步：下载 “个人所得税” APP</h3><div align="center"> <img src="https://pic2.zhimg.com/80/v2-257b3a17c68f54fcdc246962a7ac7299_1440w.jpg"width="400"/> </div><br><p>注册，登录，填报相应信息。</p><h3 id="2、确保-APP-更新到最新版"><a href="#2、确保-APP-更新到最新版" class="headerlink" title="2、确保 APP 更新到最新版"></a>2、确保 APP 更新到最新版</h3><p>进入首页，往下拉，看到常用业务的“收入纳税明细查询”，对，就是箭头指向那个地方，不要犹豫，点进去！</p><div align="center"> <img src="https://pic3.zhimg.com/80/v2-6b3690197227e337ed76c5fea465de12_1440w.jpg"width="400"/> </div><br><h3 id="3、不要太鸡冻，继续点进去"><a href="#3、不要太鸡冻，继续点进去" class="headerlink" title="3、不要太鸡冻，继续点进去"></a>3、不要太鸡冻，继续点进去</h3><p>进入收入明细查询之后，我们选择税款所属年度，也就是查询 2019 的税款。</p><div align="center"> <img src="https://pic1.zhimg.com/80/v2-2e536001a676cccd37b5fb73156a53b0_1440w.jpg"width="400"/> </div><br><p>选中自己有关的项目，就会看到你这过去的一年缴纳的所有税费，如果不清楚具体哪些项目有关，可以全选。</p><p><strong>激动的心，颤抖的手，注意握紧你的手机，点击查询按钮！</strong></p><div align="center"> <img src="https://i.loli.net/2020/04/11/25ZAbtVS7TiWRBF.jpg"width="400"/> </div><br><p>嚯，不查不知道，一查还真是一笔不小的钱哈，此刻相信你会跟我一样，脑子里快速地联想到，那要是都能退的话，我扁扁的钱包岂不是又可以充满自信的鼓起来了？过年的压岁钱都不用发愁了，想到这，还真是有点小激动。</p><h3 id="——分割线——"><a href="#——分割线——" class="headerlink" title="——分割线——"></a>——分割线——</h3><p>（下面是个人BB时间，不想看的直接拉到最后面帮忙点个赞哦，感谢老铁支持哦）</p><p>在国内，很多大学生、研究僧作为在校生，一般都会跟着导师做项目，这其中，你跟导师并没有签署劳动合同。</p><p>也就是说，你每个月到手的薪资实际是以劳务所得费发放，只要你好好跟着导师做项目，努力工作，表现好一点，一般都会给你发薪资。</p><p>一般来说，理工科导师的项目经费比较多，动辄几十万，上百万，导师经常会找一些研究生来和自己一起做项目，然后分给研究生一部分经费，也就是劳务所得费。</p><p>研究生能够得到的经费数量往往与导师项目的大小、多少有关，也跟导师的性格有比较大的关系，有的导师出手比较大方，学生得到的经费也就比较多一些。而且还会经常请学生吃吃饭，搞个团建啥的。</p><p>而有的导师比较节俭，对科研经费抠得很紧，每个月就给学生发那么几百块，象征下，因而学生拿到的经费就会少一些。</p><p>但是，无论发的多还是发的少，只要你税前薪资超过 800，就要扣税，看到这，是不是感觉有点心疼？</p><div align="center"> <img src="https://pic3.zhimg.com/80/v2-91e602809c8cb3b4a30393473562fcfa_1440w.jpg"width="400"/> </div><br><p>按照国家有关规定，劳务报酬个人所得税的免征额是 800元，800 元以内的部分免税,超过 800 元以上的部分，按照 20 %的比例税率交税。</p><p>举个栗子：导师每月给你发 1200，1200-800=400,超出这 400 按照 20%比例交税也就是 80，所以你实际到手 1200-80=1120。</p><p>因此，可以这么说，每月工资越多，扣的税也越多。</p><p>但是，12 月中旬，人民日报发了一条微博：</p><p><img src="https://pic3.zhimg.com/80/v2-acdb2541649263c9ddd0b0ec9d15c08a_1440w.jpg" alt="人民日报微博"></p><p>近日，国家税务总局公布关于办理2019年度个人所得税综合所得汇算清缴的公告（征求意见稿）向社会征求意见。我国首个个税汇算清缴将于2020年3月启动，年收入不超过12万可免个税汇算清缴。</p><h2 id="7种情况个税可申请退税："><a href="#7种情况个税可申请退税：" class="headerlink" title="7种情况个税可申请退税："></a>7种情况个税可申请退税：</h2><p><img src="https://pic2.zhimg.com/80/v2-2e71b867209762b6eccde0419b1fb0d1_1440w.jpg" alt="img"></p><p><img src="https://pic4.zhimg.com/80/v2-5f0c659247e7ca3b8cf4a5e42d3509af_1440w.jpg" alt="img"></p><p><img src="https://pic4.zhimg.com/80/v2-c7a1180fdb00906e63b6655ad9db51bb_1440w.jpg" alt="img"></p><p><img src="https://pic1.zhimg.com/80/v2-e5d89bdb470febd50c2414c57a421fc8_1440w.jpg" alt="img"></p><p><img src="https://pic1.zhimg.com/80/v2-28d0ef98ff807a30dcfa6afc64fd2b30_1440w.jpg" alt="img"></p><p><img src="https://pic3.zhimg.com/80/v2-0babacd0ad8e0525845e22b2e1d54d7e_1440w.jpg" alt="img"></p><p><img src="https://pic1.zhimg.com/80/v2-2939008a249fb2f3d3d6bf57cbd90014_1440w.jpg" alt="img"></p><p><img src="https://pic4.zhimg.com/80/v2-347b3e0f894439d5f2e7015fb4817bd7_1440w.jpg" alt="img"></p><p><img src="https://pic1.zhimg.com/80/v2-5afcd4a10f75785a48d9fed739c0b5e8_1440w.jpg" alt="img"></p><p>挑重点的说，其中第一种情况和第四种情况分别是：</p><p><strong>（1）2019 年度综合所得年收入额不足 6 万元,但平时预缴过个人所得税的。</strong></p><p>举例：小明 1 月领取工资 1 万元、个人缴付“三险一金” 2000元,假设没有专项附加扣除,预缴个税 90 元;其他月份每月工资4000 元,无须预缴个税。全年看,因年收入额不足 6 万元无须缴税,可申请退还预缴的 90 元。</p><p><strong>（2）没有任职受雇单位，仅取得劳务报酬、稿酬、特许权使用费所得，需通过年度汇算办理各种税前扣除的。</strong></p><p>大学生，研究僧应该就属于这种情况。</p><p>所以，按照上面说的两种情况，只要你是在校学生，跟导师做课题、项目，通过劳务所得费获得的费用，所扣的税也是可以退税的！</p><p>对！你没有听错！就是有这种操作！而是完全是合法的！</p><p>也就是说，年度汇算清缴时候你可以直接申请退费！！！</p><p>一下子仿佛就有了过年的压岁钱，开心么？</p><p><img src="https://pic2.zhimg.com/v2-efebed963f5174365a00e107ab25ecf1_b.jpg" alt="开心"></p><br/><blockquote><ul><li>本文已收录至我的 GitHub 程序员成长系列【MoreThanCode】 ，欢迎 star：<a href="https://github.com/rongweihe/MoreThanCode" target="_blank" rel="noopener">https://github.com/rongweihe/MoreThanCode</a></li><li><strong>个人公众号</strong> ：herongwei，<strong>个人独立域名博客</strong>：herongwei.com，坚持原创输出，下方扫码关注，2020，与您共同成长！</li></ul></blockquote><div align="center"> <img src="https://i.loli.net/2020/04/11/GquzYyQ5loDCALM.png"width="500"/> </div><br><p>非常感谢各位老铁能 <strong>看到这里</strong>，如果觉得本篇文章写得不错，觉得 <strong>「herongwei」是一个认真的仔</strong> 的话，<strong>求点赞，求关注，求分享，求留言哦！</strong></p><p>创作不易，各位老铁的支持和认可，就是我创作的最大动力，我们下篇文章在见！</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《小狗钱钱》读书笔记</title>
      <link href="/2020/04/11/xiao-gou-qian-qian-du-shu-bi-ji/"/>
      <url>/2020/04/11/xiao-gou-qian-qian-du-shu-bi-ji/</url>
      
        <content type="html"><![CDATA[<p>今天分享一本有趣的理财入门书《小狗钱钱》，记录一下自己的感想。</p><div align="center"> <img src="https://i.loli.net/2019/01/12/5c39e3745a285.png"width="500"/> </div><br><h2 id="一、背景介绍"><a href="#一、背景介绍" class="headerlink" title="一、背景介绍"></a>一、背景介绍</h2><p>《小狗钱钱》讲述的是一个童话故事：有一天，吉娅发现一只受伤的猎狗，并把它带回了家。可是，有谁会想到，这只普通的四脚动物居然会说话，是一个难得的理财天才呢？</p><p>吉娅和小狗成为了朋友，并从它那里得知，原来所有的愿望都是可以实现的。从这个童话故事里可以了解一些金钱的秘密和真相，以及投资、理财的办法。这个故事描述了在实施这些方法的过程中可能遇到的挑战，并且说明了一些令人难以置信的结果。</p><h2 id="二、作者简介"><a href="#二、作者简介" class="headerlink" title="二、作者简介"></a>二、作者简介</h2><blockquote><p>博多·舍费尔（Bodo Schafer）是位畅销书作家。他萃取个人经历中的精华，总结出一套投资理念。借着这套理念的帮助，欧洲成千上万的人在个人财务问题上取得了巨大的进步。</p><p>在获得财务自由之前博多也曾经历过长期的奋斗。他 16 岁时远赴美国求学，高中毕业后进入大学主修法律，之后在不同公司中担任各种重要职务。26 岁时博多陷入严重的个人财务危机，然而凭借坚强的意志和正确的投资理念，他最终摆脱了债务，获得了成功。</p><p>博多决心把他的理财知识传播给更多的人。他的著作被翻译成十几种语言在全球各地广为传播，创下了 110 周稳居德国图书排行榜首位的记录。他每年在欧洲各地的巡回演讲吸引数十万人热情参与。</p><p>–《豆瓣》</p></blockquote><p>这本书有一个很有意思的创意，也是很多西方文学中喜欢使用的手法，通过神话的手段来展示道理，让文章更加自然与流畅。会说话的小狗钱钱，相当于一个神的存在。通过这只小狗钱钱的讲述，把各种理财理论与心理知识灌输给主人公吉娅。并帮助吉娅打开了他的的理财大门。小狗钱钱这本书，我相信如果你认真读了它，并接受了它，它就是你生活是真实存在的小狗钱钱。</p><div align="center"> <img src="https://i.loli.net/2019/01/19/5c42d6f0db3df.jpg"width="400"/> </div><br><p>在整本书中，作者表达的观点，总结起来，其实就只有两点，第一个是如何达成自己的愿望，第二个是如何理财。</p><h2 id="三、-如何达成自己的愿望"><a href="#三、-如何达成自己的愿望" class="headerlink" title="三、 如何达成自己的愿望"></a>三、 如何达成自己的愿望</h2><p>主人公吉娅和大多数人一样，一开始有一个模糊的梦想，但对理财知识都是一无所知，在这种情况下，梦想也只能是梦想，看都看不清更别提实现它了。</p><p>小狗钱钱在书中的作用相当于一个资深的心灵和理财导师，在与吉娅发生过命的交情之后，开始帮助吉娅。奇迹从它阻止吉娅购买 CD 开始。整本书中关键时刻都是狗狗钱钱在开导着吉娅，让她一步步选择正确的道路。让我们看看小狗钱钱如何让吉娅达成自己的愿望。</p><ul><li><h4 id="列出一个自己想实现愿望的原因清单"><a href="#列出一个自己想实现愿望的原因清单" class="headerlink" title="列出一个自己想实现愿望的原因清单"></a>列出一个自己想实现愿望的原因清单</h4></li></ul><blockquote><p>为什么要把想做的事情列出来，书中小狗钱钱如此解释到，因为很多人如同吉娅一样，并不太清楚自己真正要的是什么，所以需要列出所有她想变富的理由。这样才可以让她更好的看清这个事情本身，知道自己最想要的是什么。</p></blockquote><ul><li><h4 id="在清单中筛选出几个最最关键的事情"><a href="#在清单中筛选出几个最最关键的事情" class="headerlink" title="在清单中筛选出几个最最关键的事情"></a>在清单中筛选出几个最最关键的事情</h4></li></ul><blockquote><p>如果不找出重点，就没有办法确切地知道自己的心里渴望的是什么，就没有努力的目标。如果目标不够坚定，一定完成不了自己的愿望的。</p></blockquote><ul><li><h4 id="不要只是试试看，而是直接行动起来"><a href="#不要只是试试看，而是直接行动起来" class="headerlink" title="不要只是试试看，而是直接行动起来"></a>不要只是试试看，而是直接行动起来</h4></li></ul><blockquote><p>我们有太多的时候，想做一个事情时需要考虑考虑，需要试试看。只有小孩子的世界才是最直接的，书中小狗钱钱就要求吉娅不要试试看。试试看意味着只是好奇，但真正付诸实现要比思考有用多了。并且做一件事的时候，不要超过 72 小时，因为过了 72 小时，你自己已经失去了最开始的好奇心，耐心也没了，基本上不会再完成这件事了，学会使用时间限制提醒自己提高效率。</p></blockquote><ul><li><h4 id="目标具体化，向着目标一步步走"><a href="#目标具体化，向着目标一步步走" class="headerlink" title="目标具体化，向着目标一步步走"></a>目标具体化，向着目标一步步走</h4></li></ul><blockquote><p>小狗钱钱使用了一个最简单的办法，使用梦想存储罐。多简单的方式。多具体的步骤。想要有钱，当然最重要的是存钱了，只有吉娅开始存第一块钱的时候，她才可能有变富的可能。如果只是想变富，她永远一块钱都没有。</p></blockquote><ul><li><h4 id="永不放弃"><a href="#永不放弃" class="headerlink" title="永不放弃"></a>永不放弃</h4></li></ul><blockquote><p>所谓万事开头难，一开始的阻力也是最大的，吉娅的爸爸与妈妈对存钱变富就嘲笑过吉娅。吉娅找不到挣钱的方法时灰心丧气想放弃，这些时候，小狗钱钱就是她最大的鼓励师。告诉她坚定目标的重要性，告诉她成功的案例，告诉她要学会面对困难，而且还要每天不间断地去做对自己未来有意义重大的事情。只要坚持不放弃，就可以变富，实现愿望。</p></blockquote><ul><li><h4 id="保持开放的心态，持续学习"><a href="#保持开放的心态，持续学习" class="headerlink" title="保持开放的心态，持续学习"></a>保持开放的心态，持续学习</h4></li></ul><blockquote><p>当小狗钱钱的原主人出现前，小狗钱钱扮演老师的角色，要求吉娅记成功笔记，每天记录自己学习到的内容，形成主动学习的习惯。</p><p>将自己所有做成功的事情记录进去，每天都坚持记录。当你记成功日记的时候，你会对自身、对世界以及对成功的规律做更深入的思考，你就会越来越多的了解自己的愿望，这会使你有能力去理解别人。</p><p>要彻底了解自己和世界上的所有秘密，这是无法实现的理想，但我们可以一步步接近这个理想。而在小狗钱钱原主人出现后，小狗钱钱的出场的次数在书中开始减少，出现少但不等作用变小，吉娅已经习惯了主动学习，主动和它的老主人学习，甚至还和陶穆太太学习投资，一步步加强自己的知识与眼界。最后变成实现了愿望。</p></blockquote><h2 id="四、如何理财"><a href="#四、如何理财" class="headerlink" title="四、如何理财"></a>四、如何理财</h2><p>小狗钱钱里最生动的理财故事，恐怕是杀鹅理论了，鹅就是我们的本金，金蛋就是利息，可以我们还没把鹅养大的时候，就把她给杀了。或者有时候自己根本都没有分清哪一个是鹅或者哪一个是蛋。</p><div align="center"> <img src="https://i.loli.net/2019/01/20/5c44906ee260e.png"width="500"/> </div><br><p>做为一本小白级别的入门理财书，书里面当然充满了很多通俗的理财的知识，以及怎么有效理财，这里梳理三点。</p><ul><li><h4 id="如何赚到自己人生的第一桶金"><a href="#如何赚到自己人生的第一桶金" class="headerlink" title="如何赚到自己人生的第一桶金"></a>如何赚到自己人生的第一桶金</h4></li></ul><blockquote><p>如何赚到自己人生的第一桶金，对于很多人来说，这个话题估计肯定很吸引，但似乎不容易。</p><p>而本书说利用小孩无所畏惧的心理，把赚取第一桶金的要素直接告诉了读者：做自己熟悉的事情，在自己熟悉的领域去赚取自己的人生第一桶金。</p><p>吉娅正是帮助邻居照顾狗狗拿破仑并训练狗狗几个动作，顺利得到了第一桶金20马克。人做自己熟悉且喜欢的事情就越容易有成就感，也越有赚钱的创意出现，从而可以赚到更多的钱。</p></blockquote><ul><li><h4 id="如何让自己的财富持续增长"><a href="#如何让自己的财富持续增长" class="headerlink" title="如何让自己的财富持续增长"></a>如何让自己的财富持续增长</h4></li></ul><p>书中使用了大量的故事来让吉娅学会怎么样才能让自己的财富增长，总结出以下几点：</p><blockquote><ul><li><strong>欠债的人应当毁掉所有的信用卡。因为大多数人在使用信用卡的时候比用现金花的钱要多得多；</strong></li><li><strong>尽可能少的偿还分期贷款。为了少偿还利息而选择高的分期付款额，这样每个月剩下的生活费就更少了；</strong></li><li><strong>将不用于基本生活的钱中的一半存起来，另一半用于还债；</strong></li><li><strong>借债前反问自己“这真的有必要吗”；</strong></li><li><strong>最主要的，就是要把 50% 的收入变成本金，40% 用来存储，剩下的 10% 用来消费，也就是5-4-1理论。</strong></li></ul></blockquote><ul><li><h4 id="如何投资"><a href="#如何投资" class="headerlink" title="如何投资"></a>如何投资</h4></li></ul><p>当财富开始增长的时候，就可以考虑到投资了。书中所说的投资是指把钱投在安全的地方，并让投资的钱在多个方面进行投资，同时投资也要简单明了。这对于小孩子或者保守型的人来说，是足够了。可以让自己的投资得到最大的回报，同时不用担心有所损失。</p><p>书中同样给出了如何投资基金的知识，挑选基金时的注意事项。</p><blockquote><ul><li><p><strong>这种基金已经动作了很长在段时间并且这么长时间一直有丰厚的利润。</strong></p></li><li><p><strong>应该选择大型的跨国股票基金。</strong></p></li><li><p><strong>重点选择过去10年间基金的年终利润最好的基金。</strong></p></li></ul></blockquote><p>当然了，书中还讲述了很多关于金钱的作用，以及如何看待金钱的问题。只有对金钱的本质了解清楚，才可以更好的理财。</p><p>最后，引用书的一句话。</p><blockquote><p><strong>有一些人读过之后不会有任何改变，而另一些人读过之后开始聪明地理财，他们会拥有更幸福更富有的生活。</strong></p></blockquote><p>如果有时间，推荐去读下这本书，也许不会立马让你赚到人生第一桶金，但书中的理念，相信会对你有所帮助。</p><br/><blockquote><ul><li>本文已收录至我的 GitHub 程序员成长系列【MoreThanCode】 ，欢迎 star：<a href="https://github.com/rongweihe/MoreThanCode" target="_blank" rel="noopener">https://github.com/rongweihe/MoreThanCode</a></li><li><strong>个人公众号</strong> ：herongwei，<strong>个人独立域名博客</strong>：herongwei.com，坚持原创输出，下方扫码关注，2020，与您共同成长！</li></ul></blockquote><div align="center"> <img src="https://i.loli.net/2020/04/11/GquzYyQ5loDCALM.png"width="500"/> </div><br><p>非常感谢各位老铁能 <strong>看到这里</strong>，如果觉得本篇文章写得不错，觉得 <strong>「herongwei」是一个认真的仔</strong> 的话，<strong>求点赞，求关注，求分享，求留言哦！</strong></p><p>创作不易，各位老铁的支持和认可，就是我创作的最大动力，我们下篇文章在见！</p>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/04/06/hello-world/"/>
      <url>/2020/04/06/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>我的 2018 总结</title>
      <link href="/2020/04/05/summary-of-2018/"/>
      <url>/2020/04/05/summary-of-2018/</url>
      
        <content type="html"><![CDATA[<p>2018 匆匆而过，2019 呼啸而至，简单复盘一下自己的 2018 年吧</p><p>整体来说，2018 年成长得还不够快，受打击的还不够多。</p><h2 id="一-学习"><a href="#一-学习" class="headerlink" title="一 学习"></a><strong>一 学习</strong></h2><ul><li>2018学年专业成绩第三</li><li>开题答辩成绩专业前十</li><li>每天背单词 25+ 坚持 489 天</li><li>极客 APP 报名学习了五个专栏课程</li><li>学堂在线 学完《数据挖掘理论与实战》</li><li>开通了两个知乎专栏，开始慢慢的输出自己平时学习的一些思考和总结。</li><li>GitHub 创建了 6 个重要的 repository，follower 18，新的一年，希望自己能多关注一些开源项目，贡献一些自己的力量。</li><li>重新打理了个人博客，以前在 CSDN 上写文章，后来慢慢总觉得没有个人博客写的自由，于是就基于 GitHub+Scribble 搭建了个人博客，目前写了有 45 篇文章。新的一年，希望自己能继续坚持下去。</li><li>重新打理自己的个人公众号，虽然粉丝不多，收到了开通公众号以来的第一笔读者的赞赏，真的非常开心，没有经营过公众号的人是体会不到那种感觉的，你会觉得那就是对你原创的一种鼓励，一种赞同，一种认可，另外，我的初心是把公众号当做自己一个写日结和总结的地方，有没有多少人关注现在我真的并不在意，你说你建议我去参加什么线下运营分享会之类的，我目前可能真的没有时间和精力，因为目前的我主要是把时间和精力放在个人成长方面，想把更多的时间和精力打磨自己的专长和感兴趣的地方，我一直相信，坚持自己的一些爱好，未来一定会有意想不到的收获，希望新的一年，自己能够坚持原创，坚持分享更多更好的干货。</li></ul><h2 id="二-健身"><a href="#二-健身" class="headerlink" title="二 健身"></a><strong>二 健身</strong></h2><ul><li>主要是户外运动，跑步，一到冬天，就变懒了呀，主要是室外太冷了有木有！</li><li>今年户外健身时间共 700 小时，跑步距离达 73.71 公里，明年争取突破 100 公里。</li><li>从 20 岁到今年，体重一直控制在 60-62 kg 之间，有人可能会因为懒，各种理由，对自己体重指数没有那么在意，那么我觉得，一个人连自己的身体状况都不在乎，都懒得在乎，他还能对别的事情有什么特别的在乎吗？有人可能反驳了，工作忙啊，抽不出时间来锻炼身体，那么我想问，难道要等到自己身体出现异常，发出警报不得已进医院才后悔莫及吗？，毕竟身体是革命的本钱，就算每天下班很晚，大部分人可能下班就开始休息了，但是我觉得哪怕每天抽出 至少 10 分钟慢跑消化消化肠胃总是可以的吧，时间，就像海绵里的水，都是挤出来的。</li></ul><h2 id="三-旅游"><a href="#三-旅游" class="headerlink" title="三 旅游"></a><strong>三 旅游</strong></h2><h4 id="人，为什么要旅游？"><a href="#人，为什么要旅游？" class="headerlink" title="人，为什么要旅游？"></a><strong>人，为什么要旅游？</strong></h4><p>旅行的第一个意义在于：它无疑可以帮助我们亲身感知很多东西，让我们变得成熟。</p><p>旅行的第二个意义在于：有助于消化通过读书学习间接获得的知识和信息。</p><p>旅行的第三个意义在于：它帮我们走出自己平时生活和工作的圈子。物理学中有一个知识：任何一个封闭的系统都是向着熵增大的方向发展的，也就是变得越来越无序。举个栗子就好理解，假如给一个普通人放假一个月，让他在房间里宅一个月，一个月之后你觉得房间是越来越乱了还是越来越整洁了？而破局的关键在于打破这个封闭的系统，引入所谓的“负熵”。中国有句古话，“他山之石可以攻玉”。就是这个道理。通过旅行，换一个环境，可以让我们重新审视自己，便于我们走出困境，走得更高，更远。</p><p>其实，历史上，很多大艺术家的灵感就来自于环境变换，看到自己以前没有想象的东西和事物。然后创作出不朽的作品。</p><p>虽然我们大部分人很难从旅行中获得想那些大艺术家那样的深刻的思想收获，但是旅行无疑慢慢改变了自己一些事情的看法和一些做事的方法。</p><p>没有旅行的生活是不完整的。</p><p>那么对于我今年的旅游地点，其实不多</p><p>国庆去了北戴河玩了两天。</p><p>12 中旬去南京玩了两天。</p><p>然后就没有了。。。</p><p>打脸的感觉~~</p><h2 id="四-项目"><a href="#四-项目" class="headerlink" title="四 项目"></a><strong>四 项目</strong></h2><p>项目：今年一共负责了三个跟专业相关的项目，其中两个是临时项目，从需求确认到确定技术路线，到最后开发完成验收完毕，均在一个月左右完成。<br>另外一个项目跟进了一年多，终于在今年的 11 月初验收汇报完毕了，项目结项。</p><p>个人从项目中学到了很多知识，总的感受是，不能光学理论知识，忽略了实践的重要性，还是要结合具体项目，带着目标驱动性的学习，这样学习可能会快一点。</p><h2 id="五-复盘"><a href="#五-复盘" class="headerlink" title="五 复盘"></a><strong>五 复盘</strong></h2><h4 id="关于选择还是坚持？"><a href="#关于选择还是坚持？" class="headerlink" title="关于选择还是坚持？"></a><strong>关于选择还是坚持？</strong></h4><p>有人问，觉得自己二十多岁，一无所有，该怎么办？</p><p>我不妨建议 <strong>你从做一件小事做起，坚持一年。</strong>别想着有什么爆发的结果，单纯的坚持一年试试</p><p>那有人可能问了：坚持不下去，怎么办？</p><p>心理学说：坚持不下去，无非是两个原因：</p><p><strong>你没找到坚持这件事的乐趣，或者，你没有坚持到养成一种习惯。</strong></p><p>就比如阅读，但凡坚持阅读的人，要么会觉得阅读是有趣的，要么不拿起书就总觉得不舒服。</p><p>再比如锻炼，但凡坚持锻炼的人，要么觉得锻炼后神清气爽，要么今天不锻炼觉得生活少了点什么。</p><p>巧了，上面这两个我都很有体会。</p><p>我们都知道一万小时理论，意思就是，不管你做什么领域，从事什么行业，只要你能坚持学习 1w 小时，那么你肯定能成为行业专家。听起来很简单，只要坚持就行了，但是坚持恰恰是最难的，绝大部分人是没有这样的意志力的。</p><p>坚持其实跟自己的<strong>「意志力」</strong>直接相关的，很多人总觉得自己的意志力很薄弱，无法控制自己，然而实际上，我们对意志力的理解是狭隘的。</p><p>意志力分为两种，<strong>一种是内在的</strong>，即我们常规理解的，包括自控、自律，要做什么，不要做什么等等，<strong>另一种是外在的</strong>，这与我们所处的环境，所接触的人、事物等有关。</p><p>我这里想告诉大家的是如何更好的提升自己的<strong>内在意志力</strong>，那么建议可以先从身边可以做成的小事「刻意训练」做起，这就是我为什么坚持每天背单词，当然，背单词很重要，更重要的是背单词这件事本身，它就像一个小小的成就感在那里，无时不刻在潜意识里提醒自己是能把一件小事坚持下去的。坚持每天跑步，坚持每天读一篇文章，坚持每周健身等等等，当你把一件小事坚持下去的时候，你的意志力就已经得到了提升，并且逐渐提升自己的难度，每完成一件事，你的成就感会上升，你的意志力会逐渐强大，以后做任何事，你都会更好的坚持下去。</p><p>看吧，坚持任何一件事无非是两个原因：<strong>要么找到坚持的乐趣，或者咬紧牙把这件事养成习惯</strong>。</p><p>为什么人和人的差别这么大？</p><p>其实答案只有一个：<strong>一些人坚持做了点什么，一些人因为什么事情放弃了。</strong></p><p><strong>放弃的理由五花八门，但坚持却只有这么两个理由。</strong></p><p>这世界上几乎所有的美好，都来源于坚持。</p><p>因此，<strong>坚持比选择要重要得多。</strong> </p><p>你坚持爱一个姑娘，她或许就是你的妻子。</p><p>你坚持做一件事，它或许就是你的事业。</p><p>有人说，三十多岁，选择才开始重要，到了四十多岁，人才逐渐有了做选择的智慧。</p><p>当然，这都是建立于“贵在坚持”之上。</p><h3 id="关于未来"><a href="#关于未来" class="headerlink" title="关于未来"></a><strong>关于未来</strong></h3><ul><li>职场前 5 年尽可能选择发展快速，行业的领头羊。</li><li>在任何时候，投资自己永远是投资收益比最高的。</li><li>天才只是少数，普通人靠着持之以恒的努力，同样可以成为领域里的专家，但大部分人连努力都坚持不下去。</li><li>创业心态面对工作。</li></ul><h3 id="个人认知"><a href="#个人认知" class="headerlink" title="个人认知"></a><strong>个人认知</strong></h3><p>2018 年，个人认知有了新的提高，加入了一些不错的付费圈子，比如帅张的知识星球。</p><p>每周至少一次长文分享，主题包括技术，职场，学习方法，商业，投资，写作，管理等方面，不仅增长见识，而且还改变了我们的思维方式。</p><p>感兴趣的，可以加入看看，投资自己永远是最大的投资！</p><div align="center"> <img src="https://i.loli.net/2020/04/06/XHtVCeJ5zb8mWoM.png "width="300"/> </div><br><h3 id="最后是-2019-年学习计划"><a href="#最后是-2019-年学习计划" class="headerlink" title="最后是 2019 年学习计划"></a><strong>最后是 2019 年学习计划</strong></h3><ul><li>学完《Unix 网络编程》（卷一套接字编程 + 卷二进程控制），并且写笔记发博客，一周至少一篇</li><li>坚持每周 ARTS </li><li>微信公众号坚持每周至少两篇文章</li><li>坚持每天记录自己所学所得</li><li>新的一年，加油吧！骚年！</li></ul><br/><br/><br/><center>公众号：herongwei </center><div align="center"> <img src="https://i.loli.net/2020/04/06/SBXI8QwrDyANjbg.jpg "width="250"/> </div><br><p>原文写于： 12/31/2018</p><p>最后更新于：04/06/2020</p><p>By@herongwei</p>]]></content>
      
      
      
        <tags>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
